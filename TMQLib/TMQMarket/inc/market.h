// THIS FILE IS AUTO-GENERATED BY THE CODE-GEN SCRIPT. DO NOT EDIT.
// Defines the Market and MarketSnapshot classes, which hold market data entities.

#pragma once
#include <TMQMarket/dll.h>

#include <TMQUtils/hashers.h>
#include <TMQUtils/time.h>
#include <TMQCore/mktdata_entities.h>

#include <unordered_map>
#include <shared_mutex>

namespace TMQ
{
namespace Mkt
{

struct Name
{
	std::string tag;
	Time::Date date;

	Name() = default;
	Name( const std::string_view tag, const Time::Date date = Time::Date() )
		: tag( tag )
		, date( date )
	{}

	std::string str() const;

	TMQMarket_API static const Name LIVE;
};

template<MDEntities::c_MDEntity T>
using MktObjMap = std::unordered_map<std::string, T, TransparentStringHash, std::equal_to<>>;

// Forward declarations
class Market;
class MarketSnapshot;

class MarketReadLock
{
public:
    // Lock all entities
    explicit MarketReadLock( const Market& market );
    
    // Lock specific entities
    explicit MarketReadLock( const Market& market, const std::vector<MDEntities::Type>& entityTypes );
    
    ~MarketReadLock() = default; // RAII handles unlock
    
    // Non-copyable, moveable
    MarketReadLock( const MarketReadLock& ) = delete;
    MarketReadLock& operator=( const MarketReadLock& ) = delete;
    MarketReadLock( MarketReadLock&& ) = default;
    MarketReadLock& operator=( MarketReadLock&& ) = default;

private:
    std::vector<std::shared_lock<std::shared_mutex>> m_locks;
};

class MarketWriteLock
{
public:
    // Lock all entities
    explicit MarketWriteLock( const Market& market );
    
    // Lock specific entities
    explicit MarketWriteLock( const Market& market, const std::vector<MDEntities::Type>& entityTypes );

    ~MarketWriteLock() = default; // RAII handles unlock
    
    // Non-copyable, moveable
    MarketWriteLock( const MarketWriteLock& ) = delete;
    MarketWriteLock& operator=( const MarketWriteLock& ) = delete;
    MarketWriteLock( MarketWriteLock&& ) = default;
    MarketWriteLock& operator=( MarketWriteLock&& ) = default;

private:
    std::vector<std::unique_lock<std::shared_mutex>> m_locks;
};

class Market
{
public:
    Market() = default;
    explicit TMQMarket_API Market( const MarketSnapshot& mktSnapshot );

    // --- Methods for FXRate (FXR) ---

    [[nodiscard]] std::optional<MDEntities::FXRate> getFXRate( const std::string_view ID ) const
    {
        std::shared_lock<std::shared_mutex> sl( m_FXRatesMut );
        return getFXRateUnsafe( ID );
    }

    void setFXRate( const MDEntities::FXRate& newObj )
    {
        std::unique_lock<std::shared_mutex> ul( m_FXRatesMut );
        setFXRateUnsafe( newObj );
    }

    void setFXRate( MDEntities::FXRate&& newObj )
    {
        std::unique_lock<std::shared_mutex> ul( m_FXRatesMut );
        setFXRateUnsafe( std::move( newObj ) );
    }

    size_t getFXRateCount() const noexcept
    {
        std::shared_lock<std::shared_mutex> sl( m_FXRatesMut );
        return m_FXRates.size();
    }

    [[nodiscard]] MktObjMap<MDEntities::FXRate> getAllFXRates() const
    {
        std::shared_lock<std::shared_mutex> sl( m_FXRatesMut );
        return m_FXRates;
    }

    void setAllFXRates( const MktObjMap<MDEntities::FXRate>& newMap )
    {
        std::unique_lock<std::shared_mutex> ul( m_FXRatesMut );
        m_FXRates = newMap;
    }

    // Unsafe methods (no locking - for use when already holding appropriate locks)
    
    [[nodiscard]] std::optional<MDEntities::FXRate> getFXRateUnsafe( const std::string_view ID ) const
    {
        const auto it = m_FXRates.find( ID );
        if( it == m_FXRates.end() )
            return std::nullopt;

        return it->second;
    }

    void setFXRateUnsafe( const MDEntities::FXRate& newObj )
    {
        m_FXRates[newObj.ID] = newObj;
    }

    void setFXRateUnsafe( MDEntities::FXRate&& newObj )
    {
        m_FXRates[newObj.ID] = std::move( newObj );
    }

    // --- Methods for EQPrice (EQP) ---

    [[nodiscard]] std::optional<MDEntities::EQPrice> getEQPrice( const std::string_view ID ) const
    {
        std::shared_lock<std::shared_mutex> sl( m_EQPricesMut );
        return getEQPriceUnsafe( ID );
    }

    void setEQPrice( const MDEntities::EQPrice& newObj )
    {
        std::unique_lock<std::shared_mutex> ul( m_EQPricesMut );
        setEQPriceUnsafe( newObj );
    }

    void setEQPrice( MDEntities::EQPrice&& newObj )
    {
        std::unique_lock<std::shared_mutex> ul( m_EQPricesMut );
        setEQPriceUnsafe( std::move( newObj ) );
    }

    size_t getEQPriceCount() const noexcept
    {
        std::shared_lock<std::shared_mutex> sl( m_EQPricesMut );
        return m_EQPrices.size();
    }

    [[nodiscard]] MktObjMap<MDEntities::EQPrice> getAllEQPrices() const
    {
        std::shared_lock<std::shared_mutex> sl( m_EQPricesMut );
        return m_EQPrices;
    }

    void setAllEQPrices( const MktObjMap<MDEntities::EQPrice>& newMap )
    {
        std::unique_lock<std::shared_mutex> ul( m_EQPricesMut );
        m_EQPrices = newMap;
    }

    // Unsafe methods (no locking - for use when already holding appropriate locks)
    
    [[nodiscard]] std::optional<MDEntities::EQPrice> getEQPriceUnsafe( const std::string_view ID ) const
    {
        const auto it = m_EQPrices.find( ID );
        if( it == m_EQPrices.end() )
            return std::nullopt;

        return it->second;
    }

    void setEQPriceUnsafe( const MDEntities::EQPrice& newObj )
    {
        m_EQPrices[newObj.ID] = newObj;
    }

    void setEQPriceUnsafe( MDEntities::EQPrice&& newObj )
    {
        m_EQPrices[newObj.ID] = std::move( newObj );
    }


    // --- Misc Methods ---

    [[nodiscard]] TMQMarket_API MarketSnapshot snap() const;

    // --- Lock Acquisition Methods ---
    
    // Lock specific entities for reading
    MarketReadLock acquireReadLock( const std::vector<MDEntities::Type>& entityTypes ) const
    {
        return MarketReadLock( *this, entityTypes );
    }
    
    // Lock specific entities for writing
    MarketWriteLock acquireWriteLock( const std::vector<MDEntities::Type>& entityTypes ) const
    {
        return MarketWriteLock( *this, entityTypes );
    }
    
    // Lock all entities for reading
    MarketReadLock acquireReadLockAll() const
    {
        return MarketReadLock( *this );
    }
    
    // Lock all entities for writing
    MarketWriteLock acquireWriteLockAll() const
    {
        return MarketWriteLock( *this );
    }

private:
    MktObjMap<MDEntities::FXRate> m_FXRates;
    mutable std::shared_mutex m_FXRatesMut;
    MktObjMap<MDEntities::EQPrice> m_EQPrices;
    mutable std::shared_mutex m_EQPricesMut;

    // Friend class for accessing internal maps
    friend class MarketSnapshot;
    friend class MarketReadLock;
    friend class MarketWriteLock;

    // Helper method for lock classes to get mutex reference
    std::shared_mutex& getMutexForEntity(MDEntities::Type entityType) const;
};

class MarketSnapshot
{
public:
    // --- Methods for FXRate (FXR) ---

    [[nodiscard]] std::optional<MDEntities::FXRate> getFXRate( const std::string_view ID ) const
    {
        return get<MDEntities::FXRate>( m_FXRates, ID );
    }

    [[nodiscard]] MktObjMap<MDEntities::FXRate> getAllFXRates() const
    {
        return m_FXRates;
    }

    // --- Methods for EQPrice (EQP) ---

    [[nodiscard]] std::optional<MDEntities::EQPrice> getEQPrice( const std::string_view ID ) const
    {
        return get<MDEntities::EQPrice>( m_EQPrices, ID );
    }

    [[nodiscard]] MktObjMap<MDEntities::EQPrice> getAllEQPrices() const
    {
        return m_EQPrices;
    }

private:
	// Only a Market can create a MarketSnapshot
	MarketSnapshot() = default;
	friend class Market;

	template<MDEntities::c_MDEntity T>
	[[nodiscard]] std::optional<T> get( const MktObjMap<T>& objMap, const std::string_view ID ) const
	{
		const auto it = objMap.find( ID );
		if( it == objMap.end() )
			return std::nullopt;

		return it->second;
	}

private:
    MktObjMap<MDEntities::FXRate> m_FXRates;
    MktObjMap<MDEntities::EQPrice> m_EQPrices;
};

class ConsolidatingTIDSet
{
public:

    struct Item
    {
        Item( const MDEntities::Type type, std::optional<std::string> id = std::nullopt )
            : type( type )
            , id( id )
        {}

        bool operator ==( const Item& other ) const { return type == other.type && id == other.id; }

        TMQMarket_API bool isMatch( const Item& other ) const;

        MDEntities::Type type;
        std::optional<std::string> id;
    };

public:
    ConsolidatingTIDSet() = default;
    TMQMarket_API ConsolidatingTIDSet( const std::initializer_list<Item> items );

    TMQMarket_API void add( const Item& item );
    TMQMarket_API void del( const Item& item );

    TMQMarket_API void append( const ConsolidatingTIDSet& otherSet );
    TMQMarket_API void remove( const ConsolidatingTIDSet& otherSet );

    TMQMarket_API bool contains( const Item& item ) const;

    [[nodiscard]] const std::vector<Item>& getAll() const { return m_list; }

public:
    TMQMarket_API static const ConsolidatingTIDSet ALL_TYPES;

private:
    std::vector<Item> m_list;
};

/*
TODO: Figure out loading/saving entire market data from/to a source.

TMQMarket_API std::shared_ptr<Market> load( const Context& ctx, const std::shared_ptr<MktDataSource>& source = nullptr );
TMQMarket_API void save( const std::shared_ptr<Market> mkt, const Context& ctx, const std::shared_ptr<MktDataSource>& source = nullptr );
TMQMarket_API void save( const MarketSnapshot& mktSnapshot, const Context& ctx, const std::shared_ptr<MktDataSource>& source = nullptr );
*/

}
}