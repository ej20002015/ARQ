// THIS FILE IS AUTO-GENERATED BY THE CODE-GEN SCRIPT. DO NOT EDIT.
// Contains the full implementation of the CHRefDataSource class.

#include <TMQClickHouse/ch_refdata_source_interface.h>

#include <TMQUtils/error.h>
#include <TMQUtils/instr.h>
#include <TMQCore/logger.h>

#include "connection.h"

#include <clickhouse/client.h>

namespace TMQ
{


// --- Implementation for Currency ---

std::vector<RDEntities::Currency> CHRefDataSource::fetchLatestCurrencies()
{
    CHConn conn;

    std::vector<RDEntities::Currency> results;

    Instr::Timer tm;

    static constexpr auto SELECT_STMT = R"(
		SELECT
            ccyID,
            argMax(name, LastUpdatedTs) AS max_name,
            argMax(decimalPlaces, LastUpdatedTs) AS max_decimalPlaces,
            argMax(settlementDays, LastUpdatedTs) AS max_settlementDays,
            argMax(IsActive, LastUpdatedTs) AS max_IsActive,
            max(LastUpdatedTs) AS max_LastUpdatedTs,
            argMax(LastUpdatedBy, LastUpdatedTs) AS max_LastUpdatedBy
		FROM RefData.Currencies
        GROUP BY ccyID
		HAVING max_IsActive = 1;
	)";

    try
    {
        conn.client().Select( SELECT_STMT, [&] ( const clickhouse::Block& block )
        {
            if( block.GetRowCount() == 0 )
                return; // End of data

            auto col_ccyID = block[0]->As<clickhouse::ColumnString>();
            auto col_name = block[1]->As<clickhouse::ColumnString>();
            auto col_decimalPlaces = block[2]->As<clickhouse::ColumnUInt8>();
            auto col_settlementDays = block[3]->As<clickhouse::ColumnUInt8>();
            auto col_isActive = block[4]->As<clickhouse::ColumnUInt8>();
            auto col_lastUpdatedTs = block[5]->As<clickhouse::ColumnDateTime64>();
            auto col_lastUpdatedBy = block[6]->As<clickhouse::ColumnString>();

            results.reserve( results.size() + block.GetRowCount() );
            for( size_t i = 0; i < block.GetRowCount(); ++i )
            {
                RDEntities::Currency obj;
                obj.ccyID = col_ccyID->At( i );
                obj.name = col_name->At( i );
                obj.decimalPlaces = col_decimalPlaces->At( i );
                obj.settlementDays = col_settlementDays->At( i );
                obj._isActive = col_isActive->At( i );
                obj._lastUpdatedTs = Time::longToTp( static_cast<uint64_t>( col_lastUpdatedTs->At( i ) ) );
                obj._lastUpdatedBy = col_lastUpdatedTs->At( i );
                results.push_back( std::move( obj ) );
            }
        } );
    }
    catch( const std::exception& e )
    {
        throw TMQException( std::format( "Error executing SELECT query: {0}", e.what() ) );
    }

    Log( Module::CLICKHOUSE ).debug( "Ran Clickhouse select query in {}", tm.duration() );

    return results;
}

// TODO: Need to generate insertCurrencies and fetchAsOfCurrencies in a similar manner

[[nodiscard]] std::vector<RDEntities::Currency> CHRefDataSource::fetchAsOfCurrencies( std::chrono::system_clock::time_point asof )
{
    return std::vector<RDEntities::Currency>();
}

void CHRefDataSource::insertCurrencies( const std::vector<RDEntities::Currency>& data )
{
    CHConn conn;

    Instr::Timer tm;

    try
    {
        auto col_ccyID = std::make_shared<clickhouse::ColumnString>();
        auto col_name = std::make_shared<clickhouse::ColumnString>();
        auto col_decimalPlaces = std::make_shared<clickhouse::ColumnUInt8>();
        auto col_settlementDays = std::make_shared<clickhouse::ColumnUInt8>();
        auto col_isActive = std::make_shared<clickhouse::ColumnUInt8>();
        // col_lastUpdatedTs is set to current time in ClickHouse, so we don't need to set it here
        auto col_lastUpdatedBy = std::make_shared<clickhouse::ColumnString>(); // TODO: Maybe set this to the current user?

        for( const auto& obj : data )
        {
            col_ccyID->Append( obj.ccyID );
            col_name->Append( obj.name );
            col_decimalPlaces->Append( obj.decimalPlaces );
            col_settlementDays->Append( obj.settlementDays );
            col_isActive->Append( obj._isActive );
            col_lastUpdatedBy->Append( obj._lastUpdatedBy );
        }

        clickhouse::Block block;
        block.AppendColumn( "ccyID", col_ccyID );
        block.AppendColumn( "name", col_name );
        block.AppendColumn( "decimalPlaces", col_decimalPlaces );
        block.AppendColumn( "settlementDays", col_settlementDays );
        block.AppendColumn( "IsActive", col_isActive );
        block.AppendColumn( "LastUpdatedBy", col_lastUpdatedBy );

        conn.client().Insert( "RefData.Currencies", block );
    }
    catch( const std::exception& e )
    {
        throw TMQException( std::format( "Error executing INSERT query: {0}", e.what() ) );
    }

    Log( Module::CLICKHOUSE ).debug( "Ran Clickhouse insert query in {}", tm.duration() );
}

// --- Implementation for User ---

std::vector<RDEntities::User> CHRefDataSource::fetchLatestUsers()
{
    CHConn conn;

    std::vector<RDEntities::User> results;

    Instr::Timer tm;

    static constexpr auto SELECT_STMT = R"(
		SELECT
            userID,
            argMax(fullName, LastUpdatedTs) AS max_fullName,
            argMax(email, LastUpdatedTs) AS max_email,
            argMax(tradingDesk, LastUpdatedTs) AS max_tradingDesk,
            argMax(IsActive, LastUpdatedTs) AS max_IsActive,
            max(LastUpdatedTs) AS max_LastUpdatedTs,
            argMax(LastUpdatedBy, LastUpdatedTs) AS max_LastUpdatedBy
		FROM RefData.Users
        GROUP BY userID
		HAVING max_IsActive = 1;
	)";

    try
    {
        conn.client().Select( SELECT_STMT, [&] ( const clickhouse::Block& block )
        {
            if( block.GetRowCount() == 0 )
                return; // End of data

            auto col_userID = block[0]->As<clickhouse::ColumnString>();
            auto col_fullName = block[1]->As<clickhouse::ColumnString>();
            auto col_email = block[2]->As<clickhouse::ColumnString>();
            auto col_tradingDesk = block[3]->As<clickhouse::ColumnString>();
            auto col_isActive = block[4]->As<clickhouse::ColumnUInt8>();
            auto col_lastUpdatedTs = block[5]->As<clickhouse::ColumnDateTime64>();
            auto col_lastUpdatedBy = block[6]->As<clickhouse::ColumnString>();

            results.reserve( results.size() + block.GetRowCount() );
            for( size_t i = 0; i < block.GetRowCount(); ++i )
            {
                RDEntities::User obj;
                obj.userID = col_userID->At( i );
                obj.fullName = col_fullName->At( i );
                obj.email = col_email->At( i );
                obj.tradingDesk = col_tradingDesk->At( i );
                obj._isActive = col_isActive->At( i );
                obj._lastUpdatedTs = Time::longToTp( static_cast<uint64_t>( col_lastUpdatedTs->At( i ) ) );
                obj._lastUpdatedBy = col_lastUpdatedTs->At( i );
                results.push_back( std::move( obj ) );
            }
        } );
    }
    catch( const std::exception& e )
    {
        throw TMQException( std::format( "Error executing SELECT query: {0}", e.what() ) );
    }

    Log( Module::CLICKHOUSE ).debug( "Ran Clickhouse select query in {}", tm.duration() );

    return results;
}

// TODO: Need to generate insertUsers and fetchAsOfUsers in a similar manner

[[nodiscard]] std::vector<RDEntities::User> CHRefDataSource::fetchAsOfUsers( std::chrono::system_clock::time_point asof )
{
    return std::vector<RDEntities::User>();
}

void CHRefDataSource::insertUsers( const std::vector<RDEntities::User>& data )
{
    CHConn conn;

    Instr::Timer tm;

    try
    {
        auto col_userID = std::make_shared<clickhouse::ColumnString>();
        auto col_fullName = std::make_shared<clickhouse::ColumnString>();
        auto col_email = std::make_shared<clickhouse::ColumnString>();
        auto col_tradingDesk = std::make_shared<clickhouse::ColumnString>();
        auto col_isActive = std::make_shared<clickhouse::ColumnUInt8>();
        // col_lastUpdatedTs is set to current time in ClickHouse, so we don't need to set it here
        auto col_lastUpdatedBy = std::make_shared<clickhouse::ColumnString>(); // TODO: Maybe set this to the current user?

        for( const auto& obj : data )
        {
            col_userID->Append( obj.userID );
            col_fullName->Append( obj.fullName );
            col_email->Append( obj.email );
            col_tradingDesk->Append( obj.tradingDesk );
            col_isActive->Append( obj._isActive );
            col_lastUpdatedBy->Append( obj._lastUpdatedBy );
        }

        clickhouse::Block block;
        block.AppendColumn( "userID", col_userID );
        block.AppendColumn( "fullName", col_fullName );
        block.AppendColumn( "email", col_email );
        block.AppendColumn( "tradingDesk", col_tradingDesk );
        block.AppendColumn( "IsActive", col_isActive );
        block.AppendColumn( "LastUpdatedBy", col_lastUpdatedBy );

        conn.client().Insert( "RefData.Users", block );
    }
    catch( const std::exception& e )
    {
        throw TMQException( std::format( "Error executing INSERT query: {0}", e.what() ) );
    }

    Log( Module::CLICKHOUSE ).debug( "Ran Clickhouse insert query in {}", tm.duration() );
}


}