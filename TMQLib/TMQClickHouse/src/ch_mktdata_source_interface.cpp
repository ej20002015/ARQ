// THIS FILE IS AUTO-GENERATED BY THE CODE-GEN SCRIPT. DO NOT EDIT.
// Contains the full implementation of the CHMktDataSource class.

#include <TMQClickHouse/ch_mktdata_source_interface.h>

#include <TMQUtils/error.h>
#include <TMQUtils/instr.h>
#include <TMQCore/logger.h>

#include "connection.h"

#include <clickhouse/client.h>

namespace TMQ
{

// --- Implementation for FXRate ---

static std::vector<MDEntities::FXRate> internalFetchFXRates( const std::string_view dsh, const std::string_view mktName, const std::optional<std::string_view> ID = std::nullopt )
{
    CHConn conn( dsh );

    std::vector<MDEntities::FXRate> results;

    Instr::Timer tm;

    static constexpr auto SELECT_STMT = R"(
		SELECT
            ID,
            argMax(Source, (AsofTs, _LastUpdatedTs)) AS max_Source,
            argMax(AsofTs, (AsofTs, _LastUpdatedTs)) AS max_AsofTs,
            argMax(Mid, (AsofTs, _LastUpdatedTs)) AS max_Mid,
            argMax(Bid, (AsofTs, _LastUpdatedTs)) AS max_Bid,
            argMax(Ask, (AsofTs, _LastUpdatedTs)) AS max_Ask,
            argMax(_IsActive, (AsofTs, _LastUpdatedTs)) AS max_IsActive,
            argMax(_LastUpdatedTs, (AsofTs, _LastUpdatedTs)) AS max_LastUpdatedTs,
            argMax(_LastUpdatedBy, (AsofTs, _LastUpdatedTs)) AS max_LastUpdatedBy
		FROM MktData.FXRates
        WHERE MarketName = '{0}' {1}
        GROUP BY ID
		HAVING max_IsActive = 1;
	)";

    std::string whereClause;
    if( ID.has_value() )
        whereClause = std::format( "AND ID = '{}'", ID.value() );

    try
    {
        conn.client().Select( std::format( SELECT_STMT, mktName, whereClause ), [&] ( const clickhouse::Block& block )
        {
            if( block.GetRowCount() == 0 )
                return; // End of data

            auto col_id = block[0]->As<clickhouse::ColumnString>();
            auto col_source = block[1]->As<clickhouse::ColumnString>();
            auto col_asofTs = block[2]->As<clickhouse::ColumnDateTime64>();
            auto col_mid = block[3]->As<clickhouse::ColumnFloat64>();
            auto col_bid = block[4]->As<clickhouse::ColumnFloat64>();
            auto col_ask = block[5]->As<clickhouse::ColumnFloat64>();
            auto col_isActive = block[6]->As<clickhouse::ColumnUInt8>();
            auto col_lastUpdatedTs = block[7]->As<clickhouse::ColumnDateTime64>();
            auto col_lastUpdatedBy = block[8]->As<clickhouse::ColumnString>();

            results.reserve( results.size() + block.GetRowCount() );
            for( size_t i = 0; i < block.GetRowCount(); ++i )
            {
                MDEntities::FXRate obj;
                obj.ID = col_id->At( i );
                obj.source = col_source->At( i );
                obj.asofTs = Time::longToTp( static_cast<uint64_t>( col_asofTs->At( i ) ) );
                obj.mid = col_mid->At( i );
                obj.bid = col_bid->At( i );
                obj.ask = col_ask->At( i );
                obj._isActive = col_isActive->At( i );
                obj._lastUpdatedTs = Time::longToTp( static_cast<uint64_t>( col_lastUpdatedTs->At( i ) ) );
                obj._lastUpdatedBy = col_lastUpdatedTs->At( i );
                results.push_back( std::move( obj ) );
            }
        } );
    }
    catch( const std::exception& e )
    {
        throw TMQException( std::format( "Error executing ClickHouse SELECT query: {}", e.what() ) );
    }

    Log( Module::CLICKHOUSE ).debug( "Ran ClickHouse select query in {}", tm.duration() );

    return results;
}

std::vector<MDEntities::FXRate> CHMktDataSource::fetchFXRates( const std::string_view mktName )
{
    return internalFetchFXRates( m_dsh, mktName );
}

std::optional<MDEntities::FXRate> CHMktDataSource::fetchFXRate( const std::string_view mktName, const std::string_view ID )
{
    auto result = internalFetchFXRates( m_dsh, mktName, ID );
    return result.empty() ? std::nullopt : std::make_optional( std::move( result.front() ) );
}

// TODO: Need to create fetchAsOfFXRates in a similar manner
// TODO: Need to create some audit load capability

void CHMktDataSource::insertFXRates( const std::vector<MDEntities::FXRate>& data, const std::string_view mktName )
{
    CHConn conn( m_dsh );

    Instr::Timer tm;

    try
    {
        auto col_mktName = std::make_shared<clickhouse::ColumnString>();
        auto col_id = std::make_shared<clickhouse::ColumnString>();
        auto col_source = std::make_shared<clickhouse::ColumnString>();
        auto col_asofTs = std::make_shared<clickhouse::ColumnDateTime64>( 9 );
        auto col_mid = std::make_shared<clickhouse::ColumnFloat64>();
        auto col_bid = std::make_shared<clickhouse::ColumnFloat64>();
        auto col_ask = std::make_shared<clickhouse::ColumnFloat64>();
        auto col_isActive = std::make_shared<clickhouse::ColumnUInt8>();
        // col_lastUpdatedTs is set to current time in ClickHouse, so we don't need to set it here
        auto col_lastUpdatedBy = std::make_shared<clickhouse::ColumnString>(); // TODO: Maybe set this to the current user?

        for( const auto& obj : data )
        {
            col_mktName->Append( mktName );
            col_id->Append( obj.ID );
            col_source->Append( obj.source );
            col_asofTs->Append( Time::tpToLong( obj.asofTs ) );
            col_mid->Append( obj.mid );
            col_bid->Append( obj.bid );
            col_ask->Append( obj.ask );
            col_isActive->Append( obj._isActive );
            col_lastUpdatedBy->Append( obj._lastUpdatedBy );
        }

        clickhouse::Block block;
        block.AppendColumn( "MarketName", col_mktName );
        block.AppendColumn( "ID", col_id );
        block.AppendColumn( "Source", col_source );
        block.AppendColumn( "AsofTs", col_asofTs );
        block.AppendColumn( "Mid", col_mid );
        block.AppendColumn( "Bid", col_bid );
        block.AppendColumn( "Ask", col_ask );
        block.AppendColumn( "_IsActive", col_isActive );
        block.AppendColumn( "_LastUpdatedBy", col_lastUpdatedBy );

        conn.client().Insert( "MktData.FXRates", block );
    }
    catch( const std::exception& e )
    {
        throw TMQException( std::format( "Error executing ClickHouse INSERT query: {}", e.what() ) );
    }

    Log( Module::CLICKHOUSE ).debug( "Ran ClickHouse insert query in {}", tm.duration() );
}

// --- Implementation for EQPrice ---

static std::vector<MDEntities::EQPrice> internalFetchEQPrices( const std::string_view dsh, const std::string_view mktName, const std::optional<std::string_view> ID = std::nullopt )
{
    CHConn conn( dsh );

    std::vector<MDEntities::EQPrice> results;

    Instr::Timer tm;

    static constexpr auto SELECT_STMT = R"(
		SELECT
            ID,
            argMax(Source, (AsofTs, _LastUpdatedTs)) AS max_Source,
            argMax(AsofTs, (AsofTs, _LastUpdatedTs)) AS max_AsofTs,
            argMax(Last, (AsofTs, _LastUpdatedTs)) AS max_Last,
            argMax(Bid, (AsofTs, _LastUpdatedTs)) AS max_Bid,
            argMax(Ask, (AsofTs, _LastUpdatedTs)) AS max_Ask,
            argMax(Open, (AsofTs, _LastUpdatedTs)) AS max_Open,
            argMax(Close, (AsofTs, _LastUpdatedTs)) AS max_Close,
            argMax(Volume, (AsofTs, _LastUpdatedTs)) AS max_Volume,
            argMax(_IsActive, (AsofTs, _LastUpdatedTs)) AS max_IsActive,
            argMax(_LastUpdatedTs, (AsofTs, _LastUpdatedTs)) AS max_LastUpdatedTs,
            argMax(_LastUpdatedBy, (AsofTs, _LastUpdatedTs)) AS max_LastUpdatedBy
		FROM MktData.EQPrices
        WHERE MarketName = '{0}' {1}
        GROUP BY ID
		HAVING max_IsActive = 1;
	)";

    std::string whereClause;
    if( ID.has_value() )
        whereClause = std::format( "AND ID = '{}'", ID.value() );

    try
    {
        conn.client().Select( std::format( SELECT_STMT, mktName, whereClause ), [&] ( const clickhouse::Block& block )
        {
            if( block.GetRowCount() == 0 )
                return; // End of data

            auto col_id = block[0]->As<clickhouse::ColumnString>();
            auto col_source = block[1]->As<clickhouse::ColumnString>();
            auto col_asofTs = block[2]->As<clickhouse::ColumnDateTime64>();
            auto col_last = block[3]->As<clickhouse::ColumnFloat64>();
            auto col_bid = block[4]->As<clickhouse::ColumnFloat64>();
            auto col_ask = block[5]->As<clickhouse::ColumnFloat64>();
            auto col_open = block[6]->As<clickhouse::ColumnFloat64>();
            auto col_close = block[7]->As<clickhouse::ColumnFloat64>();
            auto col_volume = block[8]->As<clickhouse::ColumnInt64>();
            auto col_isActive = block[9]->As<clickhouse::ColumnUInt8>();
            auto col_lastUpdatedTs = block[10]->As<clickhouse::ColumnDateTime64>();
            auto col_lastUpdatedBy = block[11]->As<clickhouse::ColumnString>();

            results.reserve( results.size() + block.GetRowCount() );
            for( size_t i = 0; i < block.GetRowCount(); ++i )
            {
                MDEntities::EQPrice obj;
                obj.ID = col_id->At( i );
                obj.source = col_source->At( i );
                obj.asofTs = Time::longToTp( static_cast<uint64_t>( col_asofTs->At( i ) ) );
                obj.last = col_last->At( i );
                obj.bid = col_bid->At( i );
                obj.ask = col_ask->At( i );
                obj.open = col_open->At( i );
                obj.close = col_close->At( i );
                obj.volume = col_volume->At( i );
                obj._isActive = col_isActive->At( i );
                obj._lastUpdatedTs = Time::longToTp( static_cast<uint64_t>( col_lastUpdatedTs->At( i ) ) );
                obj._lastUpdatedBy = col_lastUpdatedTs->At( i );
                results.push_back( std::move( obj ) );
            }
        } );
    }
    catch( const std::exception& e )
    {
        throw TMQException( std::format( "Error executing ClickHouse SELECT query: {}", e.what() ) );
    }

    Log( Module::CLICKHOUSE ).debug( "Ran ClickHouse select query in {}", tm.duration() );

    return results;
}

std::vector<MDEntities::EQPrice> CHMktDataSource::fetchEQPrices( const std::string_view mktName )
{
    return internalFetchEQPrices( m_dsh, mktName );
}

std::optional<MDEntities::EQPrice> CHMktDataSource::fetchEQPrice( const std::string_view mktName, const std::string_view ID )
{
    auto result = internalFetchEQPrices( m_dsh, mktName, ID );
    return result.empty() ? std::nullopt : std::make_optional( std::move( result.front() ) );
}

// TODO: Need to create fetchAsOfEQPrices in a similar manner
// TODO: Need to create some audit load capability

void CHMktDataSource::insertEQPrices( const std::vector<MDEntities::EQPrice>& data, const std::string_view mktName )
{
    CHConn conn( m_dsh );

    Instr::Timer tm;

    try
    {
        auto col_mktName = std::make_shared<clickhouse::ColumnString>();
        auto col_id = std::make_shared<clickhouse::ColumnString>();
        auto col_source = std::make_shared<clickhouse::ColumnString>();
        auto col_asofTs = std::make_shared<clickhouse::ColumnDateTime64>( 9 );
        auto col_last = std::make_shared<clickhouse::ColumnFloat64>();
        auto col_bid = std::make_shared<clickhouse::ColumnFloat64>();
        auto col_ask = std::make_shared<clickhouse::ColumnFloat64>();
        auto col_open = std::make_shared<clickhouse::ColumnFloat64>();
        auto col_close = std::make_shared<clickhouse::ColumnFloat64>();
        auto col_volume = std::make_shared<clickhouse::ColumnInt64>();
        auto col_isActive = std::make_shared<clickhouse::ColumnUInt8>();
        // col_lastUpdatedTs is set to current time in ClickHouse, so we don't need to set it here
        auto col_lastUpdatedBy = std::make_shared<clickhouse::ColumnString>(); // TODO: Maybe set this to the current user?

        for( const auto& obj : data )
        {
            col_mktName->Append( mktName );
            col_id->Append( obj.ID );
            col_source->Append( obj.source );
            col_asofTs->Append( Time::tpToLong( obj.asofTs ) );
            col_last->Append( obj.last );
            col_bid->Append( obj.bid );
            col_ask->Append( obj.ask );
            col_open->Append( obj.open );
            col_close->Append( obj.close );
            col_volume->Append( obj.volume );
            col_isActive->Append( obj._isActive );
            col_lastUpdatedBy->Append( obj._lastUpdatedBy );
        }

        clickhouse::Block block;
        block.AppendColumn( "MarketName", col_mktName );
        block.AppendColumn( "ID", col_id );
        block.AppendColumn( "Source", col_source );
        block.AppendColumn( "AsofTs", col_asofTs );
        block.AppendColumn( "Last", col_last );
        block.AppendColumn( "Bid", col_bid );
        block.AppendColumn( "Ask", col_ask );
        block.AppendColumn( "Open", col_open );
        block.AppendColumn( "Close", col_close );
        block.AppendColumn( "Volume", col_volume );
        block.AppendColumn( "_IsActive", col_isActive );
        block.AppendColumn( "_LastUpdatedBy", col_lastUpdatedBy );

        conn.client().Insert( "MktData.EQPrices", block );
    }
    catch( const std::exception& e )
    {
        throw TMQException( std::format( "Error executing ClickHouse INSERT query: {}", e.what() ) );
    }

    Log( Module::CLICKHOUSE ).debug( "Ran ClickHouse insert query in {}", tm.duration() );
}


}