// THIS FILE IS AUTO-GENERATED BY THE CODE-GEN SCRIPT. DO NOT EDIT.
// Contains gRPC service class implementation for Reference Data Gatekeeper.

#include "refdata_gatekeeper_service.h"

#include <ARQUtils/time.h>
#include <ARQCore/logger.h>
#include <ARQGrpc/rd_entity_grpc_converters.h>

namespace ARQ
{
namespace Grpc
{
namespace RefData
{

void RefDataGatekeeperServiceImpl::init()
{
    m_verMgr = std::make_shared<VersionManagerImpl>();
    m_verMgr->init();
}

template<RDEntities::c_RDEntity T>
struct UpsertBatch
{
    using KeyType = typename RDEntities::Traits<T>::KeyType;

    UpsertBatch( const size_t reserveSize )
    {
        entities.reserve( reserveSize );
        entityID2NewVersion.reserve( reserveSize );
    }

    void add( T&& entity )
    {
        entityID2NewVersion.emplace( RDEntities::Traits<T>::getKeyVal( entity ), entity._version );
        entities.push_back( std::move( entity ) );
    }

    std::vector<T> entities;
    std::unordered_map<KeyType, uint32_t> entityID2NewVersion;
};

template<typename UpsertTraits>
grpc::Status RefDataGatekeeperServiceImpl::UpsertGeneric( grpc::ServerContext* context, const typename UpsertTraits::RequestType* request, typename UpsertTraits::ResponseType* response )
{
    const auto errResponse( [&]( const grpc::StatusCode code, const std::string_view message )
    {
        Log( Module::GRPC ).error( "{} call to RefDataGatekeeper gRPC service errored - code/message: {}/{}", UpsertTraits::grpcFunc(), static_cast<uint32_t>( code ), message );
        response->set_success( false );
        response->set_message( message );
        return grpc::Status( code, std::format( "{} call errored: {}", UpsertTraits::grpcFunc(), std::string( message ) ) );
    } );

    try
    {
        std::mutex& mut = m_verMgr->getEntityMutex( UpsertTraits::entityName() );
        std::lock_guard lock( mut );

        const Time::DateTime now = Time::DateTime::nowUTC();
        const size_t numUpsertItems = request->items_size();
        if( numUpsertItems == 0 )
            return errResponse( grpc::StatusCode::INVALID_ARGUMENT, "Invalid argument: list of entities to upsert is empty" );

        UpsertBatch<typename UpsertTraits::RDEntity> upsertBatch( numUpsertItems );
        for( size_t i = 0; i < numUpsertItems; ++i )
        {
            const auto& entityID = UpsertTraits::getKey( request->items( i ) );
            const std::string entityIDStr = std::format( "{}", entityID );
            const uint32_t curVersion = m_verMgr->getVerUnsafe( UpsertTraits::entityName(), entityIDStr );
            const uint32_t expVersion = request->items( i ).expected_version();
            if( curVersion != expVersion )
                return errResponse( grpc::StatusCode::ABORTED, std::format( "Aborted request: Client expected current version of {} with {} [{}] to be {} - current version is actually {}", UpsertTraits::entityName(), UpsertTraits::keyName(), entityID, expVersion, curVersion ) );
            else if( upsertBatch.entityID2NewVersion.find( entityID ) != upsertBatch.entityID2NewVersion.end() )
                return errResponse( grpc::StatusCode::INVALID_ARGUMENT, std::format( "Invalid argument: Multiple {} entities with {} [{}] have been specified in request", UpsertTraits::entityName(), UpsertTraits::keyName(), entityID ) );
            else
            {
                auto entity = fromGrpcPayload( UpsertTraits::getPayload( request->items( i ) ) );
                entity._isActive = true;
                entity._lastUpdatedBy = request->items( i ).updated_by();
                entity._lastUpdatedTs = now;
                entity._version = curVersion + 1;

                upsertBatch.add( std::move( entity ) );
            }
        }

        UpsertTraits::rdSourceUpsert( m_rdSource, std::move( upsertBatch.entities ) );

        for( const auto [id, newVer] : upsertBatch.entityID2NewVersion )
            m_verMgr->setVerUnsafe( UpsertTraits::entityName(), id, newVer );

        response->set_success( true );
        response->set_message( std::format( "{} call was successful", UpsertTraits::grpcFunc() ) );
    }
    catch( const ARQException& e )
    {
        return errResponse( grpc::StatusCode::INTERNAL, std::format( "Internal error in RefDataGatekeeperServiceImpl::{}: {}", UpsertTraits::grpcFunc(), e.what() ) );
    }

    return grpc::Status::OK;
}

// --- Upsert Traits for Currency (CCY) ---

struct CurrencyUpsertTraits
{
    using RequestType = UpsertCurrenciesRequest;
    using ResponseType = UpsertCurrenciesResponse;
    using RDEntity = RDEntities::Currency;
    using ItemType = UpsertCurrenciesRequest_Item;
    using PayloadType = CurrencyPayload;

    static constexpr std::string_view grpcFunc()   { return "UpsertCurrencies"; }
    static constexpr std::string_view entityName() { return RDEntities::Traits<RDEntity>::name(); }
    static constexpr std::string_view keyName()    { return RDEntities::Traits<RDEntity>::key(); }

    static RDEntities::Traits<RDEntity>::KeyType getKey( const ItemType& reqItem )     { return reqItem.currency().ccy_id(); }
    static PayloadType                           getPayload( const ItemType& reqItem ) { return reqItem.currency(); }

    static void rdSourceUpsert( std::shared_ptr<IRefDataSource>& rdSource, std::vector<RDEntity>&& entities ) { rdSource->upsertCurrencies( std::move( entities ) ); }
};

grpc::Status RefDataGatekeeperServiceImpl::UpsertCurrencies( grpc::ServerContext* context, const UpsertCurrenciesRequest* request, UpsertCurrenciesResponse* response )
{
    Log::Context::Thread::Scoped logCtx( { { "gRPC_function", "UpsertCurrencies" } } ); // TODO: Add correlation ID
    return UpsertGeneric<CurrencyUpsertTraits>( context, request, response );
}

grpc::Status RefDataGatekeeperServiceImpl::DeactivateCurrencies( grpc::ServerContext* context, const DeactivateCurrenciesRequest* request, DeactivateCurrenciesResponse* response )
{
    // TODO: Implement
    return grpc::Status();
}

// --- Upsert Traits for User (USER) ---

struct UserUpsertTraits
{
    using RequestType = UpsertUsersRequest;
    using ResponseType = UpsertUsersResponse;
    using RDEntity = RDEntities::User;
    using ItemType = UpsertUsersRequest_Item;
    using PayloadType = UserPayload;

    static constexpr std::string_view grpcFunc()   { return "UpsertUsers"; }
    static constexpr std::string_view entityName() { return RDEntities::Traits<RDEntity>::name(); }
    static constexpr std::string_view keyName()    { return RDEntities::Traits<RDEntity>::key(); }

    static RDEntities::Traits<RDEntity>::KeyType getKey( const ItemType& reqItem )     { return reqItem.user().user_id(); }
    static PayloadType                           getPayload( const ItemType& reqItem ) { return reqItem.user(); }

    static void rdSourceUpsert( std::shared_ptr<IRefDataSource>& rdSource, std::vector<RDEntity>&& entities ) { rdSource->upsertUsers( std::move( entities ) ); }
};

grpc::Status RefDataGatekeeperServiceImpl::UpsertUsers( grpc::ServerContext* context, const UpsertUsersRequest* request, UpsertUsersResponse* response )
{
    Log::Context::Thread::Scoped logCtx( { { "gRPC_function", "UpsertUsers" } } ); // TODO: Add correlation ID
    return UpsertGeneric<UserUpsertTraits>( context, request, response );
}

grpc::Status RefDataGatekeeperServiceImpl::DeactivateUsers( grpc::ServerContext* context, const DeactivateUsersRequest* request, DeactivateUsersResponse* response )
{
    // TODO: Implement
    return grpc::Status();
}

}
}
}