// THIS FILE IS AUTO-GENERATED BY THE CODE-GEN SCRIPT. DO NOT EDIT.
// Contains gRPC service class implementation for Reference Data Reader.

#pragma once
#include "refdata_reader_service.h"

#include <ARQGrpc/rd_entity_grpc_converters.h>

namespace ARQ
{
namespace Grpc
{
namespace RefData
{

// --- Methods for Currency (CCY) ---

grpc::Status RefDataReaderServiceImpl::GetCurrencies( grpc::ServerContext* context, const GetCurrenciesRequest* request, GetCurrenciesResponse* response )
{
    try
    {
        std::vector<RDEntities::Currency> entities = m_rdSource->fetchCurrencies();
        for( auto&& entity : entities )
        {
            Currency* const protoEntity = response->add_currencies();
            toGrpc( std::move( entity ), protoEntity );
        }
    }
    catch( const ARQException& e )
    {
        return grpc::Status( grpc::StatusCode::INTERNAL, std::format( "Error in RefDataReaderServiceImpl::GetCurrencies: {}", e.what() ) );
    }

    return grpc::Status::OK;
}

grpc::Status RefDataReaderServiceImpl::GetCurrency( grpc::ServerContext* context, const GetCurrencyRequest* request, GetCurrencyResponse* response )
{
    try
    {
        std::optional<RDEntities::Currency> optEntity = m_rdSource->fetchCurrency( request->ccy_id() );
        if( optEntity.has_value() )
        {
            response->set_found( true );
            Currency* const protoEntity = response->mutable_currency();
            toGrpc( std::move( *optEntity ), protoEntity );
        }
        else
        {
            response->set_found( false );
            response->set_message( std::format( "Currency with ccyID={} not found in refdata source", request->ccy_id() ) );
        }
    }
    catch( const ARQException& e )
    {
        return grpc::Status( grpc::StatusCode::INTERNAL, std::format( "Error in RefDataReaderServiceImpl::GetCurrency: {}", e.what() ) );
    }

    return grpc::Status::OK;
}

// --- Methods for User (USER) ---

grpc::Status RefDataReaderServiceImpl::GetUsers( grpc::ServerContext* context, const GetUsersRequest* request, GetUsersResponse* response )
{
    try
    {
        std::vector<RDEntities::User> entities = m_rdSource->fetchUsers();
        for( auto&& entity : entities )
        {
            User* const protoEntity = response->add_users();
            toGrpc( std::move( entity ), protoEntity );
        }
    }
    catch( const ARQException& e )
    {
        return grpc::Status( grpc::StatusCode::INTERNAL, std::format( "Error in RefDataReaderServiceImpl::GetUsers: {}", e.what() ) );
    }

    return grpc::Status::OK;
}

grpc::Status RefDataReaderServiceImpl::GetUser( grpc::ServerContext* context, const GetUserRequest* request, GetUserResponse* response )
{
    try
    {
        std::optional<RDEntities::User> optEntity = m_rdSource->fetchUser( request->user_id() );
        if( optEntity.has_value() )
        {
            response->set_found( true );
            User* const protoEntity = response->mutable_user();
            toGrpc( std::move( *optEntity ), protoEntity );
        }
        else
        {
            response->set_found( false );
            response->set_message( std::format( "User with userID={} not found in refdata source", request->user_id() ) );
        }
    }
    catch( const ARQException& e )
    {
        return grpc::Status( grpc::StatusCode::INTERNAL, std::format( "Error in RefDataReaderServiceImpl::GetUser: {}", e.what() ) );
    }

    return grpc::Status::OK;
}

}
}
}