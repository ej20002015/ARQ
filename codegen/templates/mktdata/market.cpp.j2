{#
  // codegen-metadata
  // output_path: TMQLib/TMQMarket/src/market.cpp
#}
// THIS FILE IS AUTO-GENERATED BY THE CODE-GEN SCRIPT. DO NOT EDIT.
// Implements the Market and MarketSnapshot classes, which hold market data entities.

#include <TMQMarket/market.h>

namespace TMQ
{
namespace Mkt
{

// -------------- MktName implementation --------------

const Name Name::LIVE = { "LIVE", Time::Date() };

std::string Name::str() const
{
    return tag + ( date.isSet() ? std::format( "|{:%Y%m%d}", date ) : "" );
}

// -------------- Market implementation --------------

Market::Market( const MarketSnapshot& mktSnapshot )
{
    {% for entity in entities %}
    m_{{ entity.name_plural }}.setObjMap( mktSnapshot.m_{{ entity.name_plural }} );
    {% endfor %}
}

MarketSnapshot Market::snap() const
{
	std::unique_lock<std::shared_mutex> ul( m_mut );

	MarketSnapshot snapshot;

    {% for entity in entities %}
    snapshot.m_{{ entity.name_plural }} = m_{{ entity.name_plural }}.objMap();
    {% endfor %}

	return snapshot;
}

// -------------- ConsolidatingTIDSet implementation --------------

const ConsolidatingTIDSet ConsolidatingTIDSet::ALL_TYPES = {
    {% for entity in entities %}
    { MDEntities::Type::{{ entity.type_string }} },
    {% endfor %}
};

ConsolidatingTIDSet::ConsolidatingTIDSet( const std::initializer_list<Item> items )
{
    for( const Item& item : items )
        add( item );
}

bool ConsolidatingTIDSet::Item::isMatch( const ConsolidatingTIDSet::Item& other ) const
{
    if( type != other.type )
        return false;
    else if( !id.has_value() || !other.id.has_value() )
        return true;
    else if( id.value() == other.id.value() )
        return true;
    else
        return false;
}

void ConsolidatingTIDSet::add( const Item& item )
{
    if( !item.id.has_value() )
    {
        m_list.erase( std::remove_if( m_list.begin(), m_list.end(), [&item] ( const Item& i ) { return i.type == item.type; } ), m_list.end() );
        m_list.push_back( item );
    }
    else
    {
        if( std::find( m_list.begin(), m_list.end(), item ) == m_list.end() )
            m_list.push_back( item );
    }
}

void ConsolidatingTIDSet::del( const Item& item )
{
    if( !item.id.has_value() )
        m_list.erase( std::remove_if( m_list.begin(), m_list.end(), [&item] ( const Item& i ) { return i.type == item.type; } ), m_list.end() );
    else
    {
        const auto it = std::find( m_list.begin(), m_list.end(), item );
        if( it != m_list.end() )
            m_list.erase( it );
    }
}

void ConsolidatingTIDSet::append( const ConsolidatingTIDSet& otherList )
{
    for( const Item& item : otherList.getAll() )
        add( item );
}

void ConsolidatingTIDSet::remove( const ConsolidatingTIDSet& otherList )
{
    for( const Item& item : otherList.getAll() )
        del( item );
}

bool ConsolidatingTIDSet::contains( const Item& item ) const
{
    for( const Item& listItem : m_list )
    {
        if( item.isMatch( listItem ) )
            return true;
    }

    return false;
}

}
}