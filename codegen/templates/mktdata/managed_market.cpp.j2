{#
  // codegen-metadata
  // output_path: TMQLib/TMQMarket/src/managed_market.cpp
#}
// THIS FILE IS AUTO-GENERATED BY THE CODE-GEN SCRIPT. DO NOT EDIT.
// Implements the ManagedMarket class, which manages subscriptions to market data updates.

#include <TMQMarket/managed_market.h>

#include <TMQUtils/core.h>
#include <TMQCore/logger.h>
#include <TMQCore/mktdata_source.h>

namespace TMQ
{
namespace Mkt
{

// -------------- Subscriber implementation --------------

void Subscriber::setOnMktObjUpdateFunc( OnMktObjUpdateFunc&& onMktObjUpdateFunc )
{
    std::unique_lock<std::shared_mutex> ul( m_mut );
    m_onMktObjUpdateFunc = std::move( onMktObjUpdateFunc );
}

{% for entity in entities %}
void Subscriber::setOn{{ entity.name }}UpdateFunc( On{{ entity.name }}UpdateFunc&& on{{ entity.name }}UpdateFunc )
{
    std::unique_lock<std::shared_mutex> ul( m_mut );
    m_on{{ entity.name }}UpdateFunc = std::move( on{{ entity.name }}UpdateFunc );
}

{% endfor %}
// -------------- ManagedMarket implementation --------------

static bool isMktObjXNewerThanY( const MDEntities::MDEntity& x, const MDEntities::MDEntity& y )
{
	return x.asofTs > y.asofTs || ( x.asofTs == y.asofTs && x._lastUpdatedTs > y._lastUpdatedTs );
}

static std::string getSubscriberName( const std::weak_ptr<Subscriber> subscriber )
{
	if( auto subSharedPtr = subscriber.lock() )
		return subSharedPtr->description().data();
	else
		return "?nullptr?";
}

void ManagedMarket::subscribe( const std::weak_ptr<Subscriber> subscriber, const ConsolidatingTIDSet& subList )
{
	std::unique_lock<std::shared_mutex> ul( m_subMut );
	m_subscriptions[subscriber].append( subList );
}

void ManagedMarket::subscribeAndLoad( const std::weak_ptr<Subscriber> subscriber, const ConsolidatingTIDSet& subList )
{
	{
		std::unique_lock<std::shared_mutex> ul( m_subMut );
		m_subscriptions[subscriber].append( subList );
	}

	load( subList );
}

void ManagedMarket::unsubscribe( const std::weak_ptr<Subscriber> subscriber, const std::optional<std::reference_wrapper<ConsolidatingTIDSet>>& subList )
{
	// TODO: Need to have logic to check for old subscribers that have gone null and to remove them from m_subscriptions
	std::unique_lock<std::shared_mutex> ul( m_subMut );

	const auto it = m_subscriptions.find( subscriber );
	if( it == m_subscriptions.end() )
	{
		Log( Module::MKT ).warn( "ManagedMarket [{}, {}]: attempting to unsubscribe subscriber [{}] that isn't registered with the managed market", m_mktName.str(), m_dsh, getSubscriberName( subscriber ) );
		return;
	}

	if( subList.has_value() )
		it->second.remove( *subList );
	else
		m_subscriptions.erase( it );
}

void ManagedMarket::load( const ConsolidatingTIDSet& toLoad )
{
	const auto mktSrc = MktDataSourceRepo::get( MktDataSourceRepo::ClickHouse ); // TODO: Temp whilst I work out the dsh flow

	for( const ConsolidatingTIDSet::Item item : toLoad.getAll() )
	{
		switch( item.type )
		{
            {% for entity in entities %}
			case MDEntities::Type::{{ entity.type_string }}:
			{
				std::vector<MDEntities::{{ entity.name }}> loadedObjs;
				if( !item.id.has_value() )
					loadedObjs = mktSrc->fetch{{ entity.name_plural }}( m_mktName.str() );
				else
				{
					std::optional<MDEntities::{{ entity.name }}> obj = mktSrc->fetch{{ entity.name }}( m_mktName.str(), *item.id );
					if( obj.has_value() )
						loadedObjs.emplace_back( std::move( *obj ) );
				}

				for( MDEntities::{{ entity.name }}& loadedObj : loadedObjs )
				{
					// TODO: this checking should be done whilst having a lock on what's being added to the market obj map - we need a ConcurrentMarket and a normal Market that this ManagedMarket uses (is that the same as the MarketSnapshot?)
					std::optional<MDEntities::{{ entity.name }}> objInMkt = m_mkt.get{{ entity.name }}( loadedObj.ID );
					const bool insertIntoMkt = !objInMkt.has_value() || isMktObjXNewerThanY( loadedObj, *objInMkt );
					if( insertIntoMkt )
						m_mkt.set{{ entity.name }}( std::move( loadedObj ) );
				}

                break;
			}
            {% endfor %}
            default:
                TMQ_ASSERT( false );
		}
	}
}

template<MDEntities::c_MDEntity T>
void ManagedMarket::sendMktUpdateToSubscribers( const T& updatedObj )
{
	std::shared_lock<std::shared_mutex> sl( m_subMut );

	for( const auto& [subscriber, interestedIn] : m_subscriptions )
	{
		if( interestedIn.contains( { MDEntities::Traits<T>::typeEnum(), updatedObj.ID } ) )
		{
			if( auto subSharedPtr = subscriber.lock() )
			{
                std::shared_lock<std::shared_mutex> subLock( subSharedPtr->m_mut );

				if( subSharedPtr->m_onMktObjUpdateFunc )
					subSharedPtr->m_onMktObjUpdateFunc( MDEntities::Traits<T>::typeEnum(), updatedObj.ID );

                {% for entity in entities %}
                if constexpr( std::is_same_v<T, MDEntities::{{ entity.name }}> )
				{
					if( subSharedPtr->m_on{{ entity.name }}UpdateFunc )
						subSharedPtr->m_on{{ entity.name }}UpdateFunc( updatedObj );
				}
                {% endfor %}
			}
		}
	}
}
{% for entity in entities %}

void ManagedMarket::on{{ entity.name }}Update( const MDEntities::{{ entity.name }}& updatedObj )
{
	// TODO: this checking should be done whilst having a lock on what's being added to the market obj map - we need a ConcurrentMarket and a normal Market that this ManagedMarket uses (is that the same as the MarketSnapshot?)
	std::optional<MDEntities::{{ entity.name }}> objInMkt = m_mkt.get{{ entity.name }}( updatedObj.ID );
	const bool insertIntoMkt = !objInMkt.has_value() || isMktObjXNewerThanY( updatedObj, *objInMkt );

	if( !insertIntoMkt )
	{
		Log( Module::MKT ).error( "ManagedMarket [{}, {}]: Updated [{{ entity.type_string }}#{}] with asof {} is older than that already stored in the mkt which has asof {}", m_mktName.str(), m_dsh, updatedObj.ID, Time::tpToISO8601Str( updatedObj.asofTs ), Time::tpToISO8601Str( objInMkt->_lastUpdatedTs ) );
		return;
	}

	m_mkt.set{{ entity.name }}( updatedObj );

	sendMktUpdateToSubscribers<MDEntities::{{ entity.name }}>( updatedObj );
}
{% endfor %}

}
}