{#
  // codegen-metadata
  // output_path: ARQLib/ARQMarket/src/managed_market.cpp
#}
// THIS FILE IS AUTO-GENERATED BY THE CODE-GEN SCRIPT. DO NOT EDIT.
// Implements the ManagedMarket class, which manages subscriptions to market data updates.

#include <ARQMarket/managed_market.h>

#include <ARQUtils/core.h>
#include <ARQCore/logger.h>
#include <ARQCore/mktdata_source.h>

namespace ARQ
{
namespace Mkt
{

// -------------- Subscriber implementation --------------

void Subscriber::setOnMktObjUpdateFunc( OnMktObjUpdateFunc&& onMktObjUpdateFunc )
{
    std::unique_lock<std::shared_mutex> ul( m_mut );
    m_onMktObjUpdateFunc = std::move( onMktObjUpdateFunc );
}

{% for entity in entities %}
void Subscriber::setOn{{ entity.name }}UpdateFunc( On{{ entity.name }}UpdateFunc&& on{{ entity.name }}UpdateFunc )
{
    std::unique_lock<std::shared_mutex> ul( m_mut );
    m_on{{ entity.name }}UpdateFunc = std::move( on{{ entity.name }}UpdateFunc );
}

{% endfor %}
// -------------- ManagedMarket implementation --------------

static bool isMktObjXNewerThanY( const MDEntities::MDEntity& x, const MDEntities::MDEntity& y )
{
	return x.asofTs > y.asofTs || ( x.asofTs == y.asofTs && x._lastUpdatedTs > y._lastUpdatedTs );
}

static std::string getSubscriberName( const std::weak_ptr<Subscriber> subscriber )
{
	if( auto subSharedPtr = subscriber.lock() )
		return subSharedPtr->description().data();
	else
		return "?nullptr?";
}

void ManagedMarket::subscribe( const std::weak_ptr<Subscriber> subscriber, const ConsolidatingTIDSet& subList )
{
	std::unique_lock<std::shared_mutex> ul( m_subMut );
	m_subscriptions[subscriber].append( subList );
}

void ManagedMarket::subscribeAndLoad( const std::weak_ptr<Subscriber> subscriber, const ConsolidatingTIDSet& subList )
{
	{
		std::unique_lock<std::shared_mutex> ul( m_subMut );
		m_subscriptions[subscriber].append( subList );
	}

	load( subList );
}

void ManagedMarket::unsubscribe( const std::weak_ptr<Subscriber> subscriber, const std::optional<std::reference_wrapper<ConsolidatingTIDSet>>& subList )
{
	std::unique_lock<std::shared_mutex> ul( m_subMut );

	const auto it = m_subscriptions.find( subscriber );
	if( it == m_subscriptions.end() )
	{
		Log( Module::MKT ).warn( "ManagedMarket [{}, {}]: attempting to unsubscribe subscriber [{}] that isn't registered with the managed market", m_mktName.str(), m_dsh, getSubscriberName( subscriber ) );
		return;
	}

	if( subList.has_value() )
		it->second.remove( *subList );
	else
		m_subscriptions.erase( it );
}

bool ManagedMarket::isSubscriber( const std::weak_ptr<Subscriber> subscriber ) const
{
	std::shared_lock<std::shared_mutex> sl( m_subMut );
	return m_subscriptions.find( subscriber ) != m_subscriptions.end();
}

void ManagedMarket::load( const ConsolidatingTIDSet& toLoad )
{
	const auto mktSrc = MktDataSourceFactory::create( m_dsh );

	for( const ConsolidatingTIDSet::Item item : toLoad.getAll() )
	{
		switch( item.type )
		{
            {% for entity in entities %}
			case MDEntities::Type::{{ entity.type_string }}:
			{
				std::vector<MDEntities::{{ entity.name }}> loadedObjs;
				if( !item.id.has_value() )
					loadedObjs = mktSrc->fetch{{ entity.name_plural }}( m_mktName.str() );
				else
				{
					std::optional<MDEntities::{{ entity.name }}> obj = mktSrc->fetch{{ entity.name }}( m_mktName.str(), *item.id );
					if( obj.has_value() )
						loadedObjs.emplace_back( std::move( *obj ) );
				}

				for( MDEntities::{{ entity.name }}& loadedObj : loadedObjs )
				{
					// Use atomic check-then-set with proper locking
					auto lock = m_mkt.acquireWriteLock( { MDEntities::Type::{{ entity.type_string }} } );
					
					std::optional<MDEntities::{{ entity.name }}> objInMkt = m_mkt.get{{ entity.name }}Unsafe( loadedObj.ID );
					const bool insertIntoMkt = !objInMkt.has_value() || isMktObjXNewerThanY( loadedObj, *objInMkt );
					if( insertIntoMkt )
						m_mkt.set{{ entity.name }}Unsafe( std::move( loadedObj ) );
				}

                break;
			}
            {% endfor %}
            default:
                ARQ_ASSERT( false );
		}
	}
}

template<MDEntities::c_MDEntity T>
void ManagedMarket::sendMktUpdateToSubscribers( const T& updatedObj )
{
	std::shared_lock<std::shared_mutex> sl( m_subMut );

	// Any subscribers that no longer exist should be removed
	std::vector<std::weak_ptr<Subscriber>> subsToRemove;

	for( const auto& [subscriber, interestedIn] : m_subscriptions )
	{
		if( interestedIn.contains( { MDEntities::Traits<T>::typeEnum(), updatedObj.ID } ) )
		{
			if( auto subSharedPtr = subscriber.lock() )
			{
                std::shared_lock<std::shared_mutex> subLock( subSharedPtr->m_mut );

				if( subSharedPtr->m_onMktObjUpdateFunc )
					subSharedPtr->m_onMktObjUpdateFunc( MDEntities::Traits<T>::typeEnum(), updatedObj.ID );

                {% for entity in entities %}
                if constexpr( std::is_same_v<T, MDEntities::{{ entity.name }}> )
				{
					if( subSharedPtr->m_on{{ entity.name }}UpdateFunc )
						subSharedPtr->m_on{{ entity.name }}UpdateFunc( updatedObj );
				}
                {% endfor %}
			}
			else
				subsToRemove.push_back( subscriber );
		}
	}

	for( const auto subToRemove : subsToRemove )
		m_subscriptions.erase( subToRemove );
}
{% for entity in entities %}

void ManagedMarket::on{{ entity.name }}Update( const MDEntities::{{ entity.name }}& updatedObj )
{
	{
		// Use atomic check-then-set with proper locking
		auto lock = m_mkt.acquireWriteLock( { MDEntities::Type::{{ entity.type_string }} } );
		
		std::optional<MDEntities::{{ entity.name }}> objInMkt = m_mkt.get{{ entity.name }}Unsafe( updatedObj.ID );
		const bool insertIntoMkt = !objInMkt.has_value() || isMktObjXNewerThanY( updatedObj, *objInMkt );

		if( !insertIntoMkt )
		{
			Log( Module::MKT ).error( "ManagedMarket [{}, {}]: Updated [{{ entity.type_string }}#{}] with asof {} is older than that already stored in the mkt which has asof {}", m_mktName.str(), m_dsh, updatedObj.ID, updatedObj.asofTs.fmtISO8601(), objInMkt->_lastUpdatedTs.fmtISO8601() );
			return;
		}

		m_mkt.set{{ entity.name }}Unsafe( updatedObj );
	}
	
	sendMktUpdateToSubscribers<MDEntities::{{ entity.name }}>( updatedObj );
}
{% endfor %}

}
}