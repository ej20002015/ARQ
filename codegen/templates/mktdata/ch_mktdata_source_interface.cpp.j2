{#
  // codegen-metadata
  // output_path: TMQLib/TMQClickHouse/src/ch_mktdata_source_interface.cpp
#}
// THIS FILE IS AUTO-GENERATED BY THE CODE-GEN SCRIPT. DO NOT EDIT.
// Contains the full implementation of the CHMktDataSource class.

#include <TMQClickHouse/ch_mktdata_source_interface.h>

#include <TMQUtils/error.h>
#include <TMQUtils/instr.h>
#include <TMQCore/logger.h>

#include "connection.h"

#include <clickhouse/client.h>

namespace TMQ
{

{% for entity in entities %}
// --- Implementation for {{ entity.name }} ---

static std::vector<MDEntities::{{ entity.name }}> internalFetch{{ entity.name_plural }}( const std::string_view dsh, const std::string_view mktName, const std::optional<std::string_view> ID = std::nullopt )
{
    CHConn conn( dsh );

    std::vector<MDEntities::{{ entity.name }}> results;

    Instr::Timer tm;

    static constexpr auto SELECT_STMT = R"(
		SELECT
            ID,
            argMax(Source, (AsofTs, _LastUpdatedTs)) AS max_Source,
            argMax(AsofTs, (AsofTs, _LastUpdatedTs)) AS max_AsofTs,
            {% for member in entity.members %}
            argMax({{ member.name | capitalise_first }}, (AsofTs, _LastUpdatedTs)) AS max_{{ member.name | capitalise_first }},
            {% endfor %}
            argMax(_IsActive, (AsofTs, _LastUpdatedTs)) AS max_IsActive,
            argMax(_LastUpdatedTs, (AsofTs, _LastUpdatedTs)) AS max_LastUpdatedTs,
            argMax(_LastUpdatedBy, (AsofTs, _LastUpdatedTs)) AS max_LastUpdatedBy
		FROM MktData.{{ entity.table_name }}
        WHERE MarketName = '{0}' {1}
        GROUP BY ID
		HAVING max_IsActive = 1;
	)";

    std::string whereClause;
    if( ID.has_value() )
        whereClause = std::format( "AND ID = '{}'", ID.value() );

    try
    {
        conn.client().Select( std::format( SELECT_STMT, mktName, whereClause ), [&] ( const clickhouse::Block& block )
        {
            if( block.GetRowCount() == 0 )
                return; // End of data

            auto col_id = block[0]->As<clickhouse::ColumnString>();
            auto col_source = block[1]->As<clickhouse::ColumnString>();
            auto col_asofTs = block[2]->As<clickhouse::ColumnDateTime64>();
            {% for member in entity.members %}
            auto col_{{ member.name }} = block[{{ loop.index0 + 3 }}]->As<clickhouse::Column{{ types[member.type].clickhouse}}>();
            {% endfor %}
            auto col_isActive = block[{{ entity.members | length + 3 }}]->As<clickhouse::ColumnUInt8>();
            auto col_lastUpdatedTs = block[{{ entity.members | length + 4 }}]->As<clickhouse::ColumnDateTime64>();
            auto col_lastUpdatedBy = block[{{ entity.members | length + 5 }}]->As<clickhouse::ColumnString>();

            results.reserve( results.size() + block.GetRowCount() );
            for( size_t i = 0; i < block.GetRowCount(); ++i )
            {
                MDEntities::{{ entity.name }} obj;
                obj.ID = col_id->At( i );
                obj.source = col_source->At( i );
                obj.asofTs = Time::longToTp( static_cast<uint64_t>( col_asofTs->At( i ) ) );
                {% for member in entity.members %}
                {% if types[member.type].clickhouse == "DateTime64(9)" %}
                obj.{{ member.name }} = Time::longToTp( static_cast<uint64_t>( col_{{ member.name }}->At( i ) ) );
                {% else %}
                obj.{{ member.name }} = col_{{ member.name }}->At( i );
                {% endif %}
                {%- endfor %}
                obj._isActive = col_isActive->At( i );
                obj._lastUpdatedTs = Time::longToTp( static_cast<uint64_t>( col_lastUpdatedTs->At( i ) ) );
                obj._lastUpdatedBy = col_lastUpdatedTs->At( i );
                results.push_back( std::move( obj ) );
            }
        } );
    }
    catch( const std::exception& e )
    {
        throw TMQException( std::format( "Error executing ClickHouse SELECT query: {}", e.what() ) );
    }

    Log( Module::CLICKHOUSE ).debug( "Ran ClickHouse select query in {}", tm.duration() );

    return results;
}

std::vector<MDEntities::{{ entity.name }}> CHMktDataSource::fetch{{ entity.name_plural }}( const std::string_view mktName )
{
    return internalFetch{{ entity.name_plural }}( m_dsh, mktName );
}

std::optional<MDEntities::{{ entity.name }}> CHMktDataSource::fetch{{ entity.name }}( const std::string_view mktName, const std::string_view ID )
{
    auto result = internalFetch{{ entity.name_plural }}( m_dsh, mktName, ID );
    return result.empty() ? std::nullopt : std::make_optional( std::move( result.front() ) );
}

// TODO: Need to create fetchAsOf{{ entity.name_plural }} in a similar manner
// TODO: Need to create some audit load capability

void CHMktDataSource::insert{{ entity.name_plural }}( const std::vector<MDEntities::{{ entity.name }}>& data, const std::string_view mktName )
{
    CHConn conn( m_dsh );

    Instr::Timer tm;

    try
    {
        auto col_mktName = std::make_shared<clickhouse::ColumnString>();
        auto col_id = std::make_shared<clickhouse::ColumnString>();
        auto col_source = std::make_shared<clickhouse::ColumnString>();
        auto col_asofTs = std::make_shared<clickhouse::ColumnDateTime64>( 9 );
        {% for member in entity.members %}
        {% if types[member.type].clickhouse == "DateTime64(9)" %}
        auto col_{{ member.name }} = std::make_shared<clickhouse::ColumnDateTime64>( 9 );
        {% else %}
        auto col_{{ member.name }} = std::make_shared<clickhouse::Column{{ types[member.type].clickhouse }}>();
        {% endif %}
        {% endfor %}
        auto col_isActive = std::make_shared<clickhouse::ColumnUInt8>();
        // col_lastUpdatedTs is set to current time in ClickHouse, so we don't need to set it here
        auto col_lastUpdatedBy = std::make_shared<clickhouse::ColumnString>(); // TODO: Maybe set this to the current user?

        for( const auto& obj : data )
        {
            col_mktName->Append( mktName );
            col_id->Append( obj.ID );
            col_source->Append( obj.source );
            col_asofTs->Append( Time::tpToLong( obj.asofTs ) );
            {% for member in entity.members %}
            {% if types[member.type].clickhouse == "DateTime64(9)" %}
            col_{{ member.name }}->Append( Time::tpToLong( obj.{{ member.name }} ) );
            {% else %}
            col_{{ member.name }}->Append( obj.{{ member.name }} );
            {% endif %}
            {% endfor %}
            col_isActive->Append( obj._isActive );
            col_lastUpdatedBy->Append( obj._lastUpdatedBy );
        }

        clickhouse::Block block;
        block.AppendColumn( "MarketName", col_mktName );
        block.AppendColumn( "ID", col_id );
        block.AppendColumn( "Source", col_source );
        block.AppendColumn( "AsofTs", col_asofTs );
        {% for member in entity.members %}
        block.AppendColumn( "{{ member.name | capitalise_first }}", col_{{ member.name }} );
        {% endfor %}
        block.AppendColumn( "_IsActive", col_isActive );
        block.AppendColumn( "_LastUpdatedBy", col_lastUpdatedBy );

        conn.client().Insert( "MktData.{{ entity.table_name }}", block );
    }
    catch( const std::exception& e )
    {
        throw TMQException( std::format( "Error executing ClickHouse INSERT query: {}", e.what() ) );
    }

    Log( Module::CLICKHOUSE ).debug( "Ran ClickHouse insert query in {}", tm.duration() );
}

{% endfor %}

}