{#
  // codegen-metadata
  // output_path: TMQLib/TMQClickHouse/src/ch_refdata_source_interface.cpp
#}
// THIS FILE IS AUTO-GENERATED BY THE CODE-GEN SCRIPT. DO NOT EDIT.
// Contains the full implementation of the CHRefDataSource class.

#include <TMQClickHouse/ch_refdata_source_interface.h>

#include <TMQUtils/error.h>
#include <TMQUtils/instr.h>
#include <TMQCore/logger.h>

#include "connection.h"

#include <clickhouse/client.h>

namespace TMQ
{


{% for entity in entities %}
// --- Implementation for {{ entity.name }} ---

std::vector<RDEntities::{{ entity.name }}> CHRefDataSource::fetchLatest{{ entity.name_plural }}()
{
    CHConn conn( m_dsh );

    std::vector<RDEntities::{{ entity.name }}> results;

    Instr::Timer tm;

    static constexpr auto SELECT_STMT = R"(
		SELECT
            {{ entity.key }},
            {% for member in entity.members %}
            {% if member.name != entity.key %}
            argMax({{ member.name | capitalise_first }}, _LastUpdatedTs) AS max_{{ member.name | capitalise_first }},
            {% endif %}
            {% endfor %}
            argMax(_IsActive, _LastUpdatedTs) AS max_IsActive,
            max(_LastUpdatedTs) AS max_LastUpdatedTs,
            argMax(_LastUpdatedBy, _LastUpdatedTs) AS max_LastUpdatedBy
		FROM RefData.{{ entity.table_name }}
        GROUP BY {{ entity.key }}
		HAVING max_IsActive = 1;
	)";

    try
    {
        conn.client().Select( SELECT_STMT, [&] ( const clickhouse::Block& block )
        {
            if( block.GetRowCount() == 0 )
                return; // End of data

            {% for member in entity.members %}
            auto col_{{ member.name }} = block[{{ loop.index0 }}]->As<clickhouse::Column{{ types[member.type].clickhouse}}>();
            {% endfor %}
            auto col_isActive = block[{{ entity.members | length }}]->As<clickhouse::ColumnUInt8>();
            auto col_lastUpdatedTs = block[{{ entity.members | length + 1 }}]->As<clickhouse::ColumnDateTime64>();
            auto col_lastUpdatedBy = block[{{ entity.members | length + 2 }}]->As<clickhouse::ColumnString>();

            results.reserve( results.size() + block.GetRowCount() );
            for( size_t i = 0; i < block.GetRowCount(); ++i )
            {
                RDEntities::{{ entity.name }} obj;
                {% for member in entity.members %}
                {% if types[member.type].clickhouse == "DateTime64(9)" %}
                obj.{{ member.name }} = Time::longToTp( static_cast<uint64_t>( col_{{ member.name }}->At( i ) ) );
                {% else %}
                obj.{{ member.name }} = col_{{ member.name }}->At( i );
                {% endif %}
                {%- endfor %}
                obj._isActive = col_isActive->At( i );
                obj._lastUpdatedTs = Time::longToTp( static_cast<uint64_t>( col_lastUpdatedTs->At( i ) ) );
                obj._lastUpdatedBy = col_lastUpdatedTs->At( i );
                results.push_back( std::move( obj ) );
            }
        } );
    }
    catch( const std::exception& e )
    {
        throw TMQException( std::format( "Error executing ClickHouse SELECT query: {}", e.what() ) );
    }

    Log( Module::CLICKHOUSE ).debug( "Ran ClickHouse select query in {}", tm.duration() );

    return results;
}

// TODO: Need to implement fetchAsOf{{ entity.name_plural }} in a similar manner
// TODO: Need to create some audit load capability

[[nodiscard]] std::vector<RDEntities::{{ entity.name }}> CHRefDataSource::fetchAsOf{{ entity.name_plural }}( std::chrono::system_clock::time_point asof )
{
    return std::vector<RDEntities::{{ entity.name }}>();
}

void CHRefDataSource::insert{{ entity.name_plural }}( const std::vector<RDEntities::{{ entity.name }}>& data )
{
    CHConn conn( m_dsh );

    Instr::Timer tm;

    try
    {
        {% for member in entity.members %}
        {% if types[member.type].clickhouse == "DateTime64(9)" %}
        auto col_{{ member.name }} = std::make_shared<clickhouse::ColumnDateTime64>( 9 );
        {% else %}
        auto col_{{ member.name }} = std::make_shared<clickhouse::Column{{ types[member.type].clickhouse }}>();
        {% endif %}
        {% endfor %}
        auto col_isActive = std::make_shared<clickhouse::ColumnUInt8>();
        // col_lastUpdatedTs is set to current time in ClickHouse, so we don't need to set it here
        auto col_lastUpdatedBy = std::make_shared<clickhouse::ColumnString>(); // TODO: Maybe set this to the current user?

        for( const auto& obj : data )
        {
            {% for member in entity.members %}
            {% if types[member.type].clickhouse == "DateTime64(9)" %}
            col_{{ member.name }}->Append( Time::tpToLong( obj.{{ member.name }} ) );
            {% else %}
            col_{{ member.name }}->Append( obj.{{ member.name }} );
            {% endif %}
            {% endfor %}
            col_isActive->Append( obj._isActive );
            col_lastUpdatedBy->Append( obj._lastUpdatedBy );
        }

        clickhouse::Block block;
        {% for member in entity.members %}
        block.AppendColumn( "{{ member.name | capitalise_first }}", col_{{ member.name }} );
        {% endfor %}
        block.AppendColumn( "_IsActive", col_isActive );
        block.AppendColumn( "_LastUpdatedBy", col_lastUpdatedBy );

        conn.client().Insert( "RefData.{{ entity.table_name }}", block );
    }
    catch( const std::exception& e )
    {
        throw TMQException( std::format( "Error executing ClickHouse INSERT query: {0}", e.what() ) );
    }

    Log( Module::CLICKHOUSE ).debug( "Ran ClickHouse insert query in {}", tm.duration() );
}

{% endfor %}

}