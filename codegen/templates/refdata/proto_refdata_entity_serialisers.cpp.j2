{#
  // codegen-metadata
  // output_path: ARQLib/ARQProtobuf/src/proto_refdata_entity_serialisers.cpp
#}
// THIS FILE IS AUTO-GENERATED BY THE CODE-GEN SCRIPT. DO NOT EDIT.
// Contains (de)serialisation code for refdata entities

#include "proto_refdata_entity_serialisers.h"

#include <ARQUtils/id.h>
#include <ARQProtobuf/rd_entity_proto_converters.h>
#include "helpers.h"

#include <proto_gen/refdata_entities.pb.h>

namespace ARQ::Proto::RD
{

void registerRefDataEntitySerialisers( Serialiser& serialiser )
{
    {% for entity in entities %}
    serialiser.registerHandler<ARQ::RD::Record<ARQ::RD::{{ entity.name }}>>( std::make_unique<ProtobufTypeSerialiser_RDRecord<ARQ::RD::{{ entity.name }}>>() );
    {% endfor %}
}

/*
**************************************************
* Helpers for RefData entity proto serialisation *
**************************************************
*/

template<typename ProtoType>
void setRecordHeaderFields( ProtoType& protoObj, const ARQ::RD::RecordHeader& arqRecordHeader )
{
	ARQ::Proto::RD::RecordHeader* const recordHeaderPtr = protoObj.mutable_header();

    ARQ::Proto::ID::UUID* uuidPtr = recordHeaderPtr->mutable_uuid();
    std::string* uuidBufPtr = uuidPtr->mutable_id();
    *uuidBufPtr = arqRecordHeader.uuid.toString();

	recordHeaderPtr->set_is_active( arqRecordHeader.isActive );
	recordHeaderPtr->set_last_updated_ts( arqRecordHeader.lastUpdatedTs.microsecondsSinceEpoch() );
	recordHeaderPtr->set_last_updated_by( arqRecordHeader.lastUpdatedBy );
	recordHeaderPtr->set_version( arqRecordHeader.version );
}

template<typename ProtoType>
ARQ::RD::RecordHeader getRecordHeaderFromProto( ProtoType& protoObj )
{
	ARQ::Proto::RD::RecordHeader* const protoHeaderPtr = protoObj.mutable_header();

	return {
		.uuid          = ARQ::ID::UUID::fromString( protoHeaderPtr->uuid().id() ),
		.isActive      = protoHeaderPtr->is_active(),
		.lastUpdatedTs = Time::DateTime( Time::Microseconds( protoHeaderPtr->last_updated_ts() ) ),
		.lastUpdatedBy = std::move( *protoHeaderPtr->mutable_last_updated_by() ),
		.version       = protoHeaderPtr->version()
	};
}

/*
************************************************************
* Protobuf TypeSerialiser definitions for refdata entities *
************************************************************
*/

{% for entity in entities %}
// -------------------- {{ entity.name }} RefData Entity --------------------

template<>
Buffer ProtobufTypeSerialiser_RDRecord<ARQ::RD::{{ entity.name }}>::serialise( const ARQ::RD::Record<ARQ::RD::{{ entity.name }}>& obj ) const
{
	{{ entity.name }}Record protoObj;
	setRecordHeaderFields( protoObj, obj.header );

	{{ entity.name }}* dataPtr = protoObj.mutable_data();
	toProto( obj.data, dataPtr );

	return serialiseToBuffer( protoObj );
}

template<>
void ProtobufTypeSerialiser_RDRecord<ARQ::RD::{{ entity.name }}>::deserialise( const BufferView buf, ARQ::RD::Record<ARQ::RD::{{ entity.name }}>& objOut ) const
{
	{{ entity.name }}Record protoObj;
	if( !protoObj.ParseFromArray( buf.data, buf.size ) )
		throw ARQException( "Cannot deserialise buffer into RefData {{ entity.name }} Record" );

	objOut.header = getRecordHeaderFromProto( protoObj );
	objOut.data = fromProto( std::move( *protoObj.mutable_data() ) );
}

{% endfor %}
}