{#
  // codegen-metadata
  // output_path: services/RefData/RefDataGatekeeper/src/refdata_gatekeeper_service.cpp
#}
// THIS FILE IS AUTO-GENERATED BY THE CODE-GEN SCRIPT. DO NOT EDIT.
// Contains gRPC service class implementation for Reference Data Gatekeeper.

#include "refdata_gatekeeper_service.h"

#include <ARQUtils/time.h>
#include <ARQCore/logger.h>
#include <ARQGrpc/rd_entity_grpc_converters.h>

namespace ARQ
{
namespace Grpc
{
namespace RefData
{

void RefDataGatekeeperServiceImpl::init()
{
    m_verMgr = std::make_shared<VersionManagerImpl>();
    m_verMgr->init();
}

template<RDEntities::c_RDEntity T>
struct UpsertBatch
{
    using KeyType = typename RDEntities::Traits<T>::KeyType;

    UpsertBatch( const size_t reserveSize )
    {
        entities.reserve( reserveSize );
        entityID2NewVersion.reserve( reserveSize );
    }

    void add( T&& entity )
    {
        entityID2NewVersion.emplace( RDEntities::Traits<T>::getKeyVal( entity ), entity._version );
        entities.push_back( std::move( entity ) );
    }

    std::vector<T> entities;
    std::unordered_map<KeyType, uint32_t> entityID2NewVersion;
};

template<typename UpsertTraits>
grpc::Status RefDataGatekeeperServiceImpl::UpsertGeneric( grpc::ServerContext* context, const typename UpsertTraits::RequestType* request, typename UpsertTraits::ResponseType* response )
{
    const auto errResponse( [&]( const grpc::StatusCode code, const std::string_view message )
    {
        Log( Module::GRPC ).error( "{} call to RefDataGatekeeper gRPC service errored - code/message: {}/{}", UpsertTraits::grpcFunc(), static_cast<uint32_t>( code ), message );
        response->set_success( false );
        response->set_message( message );
        return grpc::Status( code, std::format( "{} call errored: {}", UpsertTraits::grpcFunc(), std::string( message ) ) );
    } );

    try
    {
        std::mutex& mut = m_verMgr->getEntityMutex( UpsertTraits::entityName() );
        std::lock_guard lock( mut );

        const Time::DateTime now = Time::DateTime::nowUTC();
        const size_t numUpsertItems = request->items_size();
        if( numUpsertItems == 0 )
            return errResponse( grpc::StatusCode::INVALID_ARGUMENT, "Invalid argument: list of entities to upsert is empty" );

        UpsertBatch<typename UpsertTraits::RDEntity> upsertBatch( numUpsertItems );
        for( size_t i = 0; i < numUpsertItems; ++i )
        {
            const auto& entityID = UpsertTraits::getKey( request->items( i ) );
            const std::string entityIDStr = std::format( "{}", entityID );
            const uint32_t curVersion = m_verMgr->getVerUnsafe( UpsertTraits::entityName(), entityIDStr );
            const uint32_t expVersion = request->items( i ).expected_version();
            if( curVersion != expVersion )
                return errResponse( grpc::StatusCode::ABORTED, std::format( "Aborted request: Client expected current version of {} with {} [{}] to be {} - current version is actually {}", UpsertTraits::entityName(), UpsertTraits::keyName(), entityID, expVersion, curVersion ) );
            else if( upsertBatch.entityID2NewVersion.find( entityID ) != upsertBatch.entityID2NewVersion.end() )
                return errResponse( grpc::StatusCode::INVALID_ARGUMENT, std::format( "Invalid argument: Multiple {} entities with {} [{}] have been specified in request", UpsertTraits::entityName(), UpsertTraits::keyName(), entityID ) );
            else
            {
                auto entity = fromGrpcPayload( UpsertTraits::getPayload( request->items( i ) ) );
                entity._isActive = true;
                entity._lastUpdatedBy = request->items( i ).updated_by();
                entity._lastUpdatedTs = now;
                entity._version = curVersion + 1;

                upsertBatch.add( std::move( entity ) );
            }
        }

        UpsertTraits::rdSourceUpsert( m_rdSource, std::move( upsertBatch.entities ) );

        for( const auto [id, newVer] : upsertBatch.entityID2NewVersion )
            m_verMgr->setVerUnsafe( UpsertTraits::entityName(), id, newVer );

        response->set_success( true );
        response->set_message( std::format( "{} call was successful", UpsertTraits::grpcFunc() ) );
    }
    catch( const ARQException& e )
    {
        return errResponse( grpc::StatusCode::INTERNAL, std::format( "Internal error in RefDataGatekeeperServiceImpl::{}: {}", UpsertTraits::grpcFunc(), e.what() ) );
    }

    return grpc::Status::OK;
}
{% for entity in entities %}

// --- Upsert Traits for {{ entity.name }} ({{ entity.type_string }}) ---

struct {{ entity.name }}UpsertTraits
{
    using RequestType = Upsert{{ entity.name_plural }}Request;
    using ResponseType = Upsert{{ entity.name_plural }}Response;
    using RDEntity = RDEntities::{{ entity.name }};
    using ItemType = Upsert{{ entity.name_plural }}Request_Item;
    using PayloadType = {{ entity.name }}Payload;

    static constexpr std::string_view grpcFunc()   { return "Upsert{{ entity.name_plural }}"; }
    static constexpr std::string_view entityName() { return RDEntities::Traits<RDEntity>::name(); }
    static constexpr std::string_view keyName()    { return RDEntities::Traits<RDEntity>::key(); }

    static RDEntities::Traits<RDEntity>::KeyType getKey( const ItemType& reqItem )     { return reqItem.{{ entity.name | snake_case }}().{{ entity.key | snake_case }}(); }
    static PayloadType                           getPayload( const ItemType& reqItem ) { return reqItem.{{ entity.name | snake_case }}(); }

    static void rdSourceUpsert( std::shared_ptr<RefDataSource>& rdSource, std::vector<RDEntity>&& entities ) { rdSource->upsert{{ entity.name_plural }}( std::move( entities ) ); }
};

grpc::Status RefDataGatekeeperServiceImpl::Upsert{{ entity.name_plural }}( grpc::ServerContext* context, const Upsert{{ entity.name_plural }}Request* request, Upsert{{ entity.name_plural }}Response* response )
{
    Log::Context::Thread::Scoped logCtx( { { "gRPC_function", "Upsert{{ entity.name_plural }}" } } ); // TODO: Add correlation ID
    return UpsertGeneric<{{ entity.name }}UpsertTraits>( context, request, response );
}

grpc::Status RefDataGatekeeperServiceImpl::Deactivate{{ entity.name_plural }}( grpc::ServerContext* context, const Deactivate{{ entity.name_plural }}Request* request, Deactivate{{ entity.name_plural }}Response* response )
{
    // TODO: Implement
    return grpc::Status();
}
{% endfor %}

}
}
}