{#
  // codegen-metadata
  // output_path: ARQLib/ARQGrpc/src/refdata_grpc_clients.cpp
#}
// THIS FILE IS AUTO-GENERATED BY THE CODE-GEN SCRIPT. DO NOT EDIT.
// Contains gRPC client stub implementation for Reference Data services.

#pragma once
#include "refdata_grpc_clients.h"

#include <ARQUtils/error.h>
#include <ARQCore/logger.h>

#include <ARQGrpc/rd_entity_grpc_converters.h>

namespace ARQ
{
namespace Grpc
{
namespace RefData
{

/*
*********************************************
*   Implementation of RefDataReaderClient   *
*********************************************
*/

{% for entity in entities %}
// --- Methods for {{ entity.name }} ({{ entity.type_string }}) ---

std::vector<RDEntities::{{ entity.name }}> RefDataReaderClient::get{{ entity.name_plural }}()
{
    Get{{ entity.name_plural }}Request request;
    Get{{ entity.name_plural }}Response response;
    grpc::ClientContext context;

    grpc::Status status = m_stub->Get{{ entity.name_plural }}( &context, request, &response );

    if( !status.ok() )
        throw ARQException( std::format( "Could not make get{{ entity.name_plural }} call to RefDataReader gRPC service - response code/message: {}/{}", static_cast<uint32_t>( status.error_code() ), status.error_message() ) );
    
    const size_t numEntities = response.{{ entity.name_plural | snake_case }}_size();
    std::vector<RDEntities::{{ entity.name }}> entities;
    entities.reserve( numEntities );
    for( size_t i = 0; i < numEntities; ++i )
    {
        {{ entity.name }}* const entity = response.mutable_{{ entity.name_plural | snake_case }}( i );
        entities.push_back( fromGrpc( std::move( *entity ) ) );
    }

    return entities;
}

std::optional<RDEntities::{{ entity.name }}> RefDataReaderClient::get{{ entity.name }}( const RDEntities::Traits<RDEntities::{{ entity.name }}>::KeyType& {{ entity.key }} )
{
    Get{{ entity.name }}Request request;
    request.set_{{ entity.key | snake_case }}( {{ entity.key }} );
    Get{{ entity.name }}Response response;
    grpc::ClientContext context;

    grpc::Status status = m_stub->Get{{ entity.name }}( &context, request, &response );
    if( !status.ok() )
        throw ARQException( std::format( "Could not make get{{ entity.name }} call to RefDataReader gRPC service - response code/message: {}/{}", static_cast<uint32_t>( status.error_code() ), status.error_message() ) );
    
     if( response.found() )
        return fromGrpc( std::move( *response.mutable_{{ entity.name | snake_case }}() ) );
    else
    {
        if( response.message().size() )
            Log( Module::GRPC ).info( "get{{ entity.name }} call to RefDataReader gRPC service with {{ entity.key | snake_case }} [{}] found no such entity - response message: {}", {{ entity.key }}, response.message() );
        return std::nullopt;
    }
}

{% endfor %}

/*
*********************************************
* Implementation of RefDataGatekeeperClient *
*********************************************
*/

{% for entity in entities %}
// --- Methods for {{ entity.name }} ({{ entity.type_string }}) ---

void RefDataGatekeeperClient::upsert{{ entity.name_plural }}( const std::vector<RDEntities::{{ entity.name }}>& data )
{
    Upsert{{ entity.name_plural }}Request request;
    for( const auto& d : data )
    {
        Upsert{{ entity.name_plural }}Request::Item* const itemPtr = request.add_items();
        itemPtr->set_expected_version( d._version );
        itemPtr->set_updated_by( "ejames" ); // TODO: Change this to be the actual user
        {{ entity.name }}Payload* const payload = itemPtr->mutable_{{ entity.name | snake_case }}();
        toGrpcPayload( d, payload );
    }
    Upsert{{ entity.name_plural }}Response response;
    grpc::ClientContext context;

    grpc::Status status = m_stub->Upsert{{ entity.name_plural }}( &context, request, &response );
    if( !status.ok() )
        throw ARQException( std::format( "Could not make upsert{{ entity.name_plural }} call to RefDataGatekeeper gRPC service - response code/message: {}/{}", static_cast<uint32_t>( status.error_code() ), status.error_message() ) );
    
    if( !response.success() ) //  TODO: Should return something
        Log( Module::GRPC ).error( "upsert{{ entity.name_plural }} call to RefDataGatekeeper gRPC service didn't succeed in saving all items - message: {}", response.message() );
}

void RefDataGatekeeperClient::deactivate{{ entity.name_plural }}( const std::vector<Deactivate{{ entity.name }}Data>& data )
{
    Deactivate{{ entity.name_plural }}Request request;
    for( const auto& [ key, version ] : data )
    {
        Deactivate{{ entity.name_plural }}Request::Item* const itemPtr = request.add_items();
        itemPtr->set_{{ entity.key | snake_case }}( key );
        itemPtr->set_expected_version( version );
        itemPtr->set_updated_by( "ejames" ); // TODO: Change this to be the actual user
    }
    Deactivate{{ entity.name_plural }}Response response;
    grpc::ClientContext context;

    grpc::Status status = m_stub->Deactivate{{ entity.name_plural }}( &context, request, &response );
    if( !status.ok() )
        throw ARQException( std::format( "Could not make deactivate{{ entity.name_plural }} call to RefDataGatekeeper gRPC service - response code/message: {}/{}", static_cast<uint32_t>( status.error_code() ), status.error_message() ) );
    
    if( !response.success() ) //  TODO: Should return something
        Log( Module::GRPC ).error( "deactivate{{ entity.name_plural }} call to RefDataGatekeeper gRPC service didn't succeed in saving all items - message: {}", response.message() );
}

{% endfor %}

}
}
}