{#
  // codegen-metadata
  // output_path: ARQLib/ARQGrpc/src/grpc_refdata_source_interface.cpp
#}
// THIS FILE IS AUTO-GENERATED BY THE CODE-GEN SCRIPT. DO NOT EDIT.
// Contains the full implementation of the GrpcRefDataSource class.

#include <ARQGrpc/grpc_refdata_source_interface.h>

#include <ARQUtils/error.h>
#include <ARQUtils/instr.h>
#include <ARQCore/logger.h>

#include <proto_gen/refdata_protobuf.grpc.pb.h>

#include "channel_manager.h"
#include "refdata_grpc_clients.h"

namespace ARQ
{


{% for entity in entities %}
// --- Implementation for {{ entity.name }} ---

static std::vector<RDEntities::{{ entity.name }}> internalFetch{{ entity.name_plural }}( const std::string_view dsh, const std::optional<std::reference_wrapper<const RDEntities::Traits<RDEntities::{{ entity.name }}>::KeyType>> {{ entity.key }} = std::nullopt )
{
    const bool singleFetch = {{ entity.key }}.has_value();

    std::vector<RDEntities::{{ entity.name }}> results;

    Instr::Timer tm;

    try
    {
        std::shared_ptr<grpc::Channel> channel = ChannelManager::inst().get( dsh, "RefDataReader" );

        ARQ::Grpc::RefData::RefDataReaderClient client( channel );
        if( singleFetch )
        {
            std::optional<RDEntities::{{ entity.name }}> result = client.get{{ entity.name }}( *{{ entity.key }} );
            if( result.has_value() )
                results.push_back( std::move( *result ) );
        }
        else
            results = client.get{{ entity.name_plural }}();
    }
    catch( const ARQException& e )
    {
        throw ARQException( std::format( "Error invoking gRPC RefDataReader::get{} function: {}", singleFetch ? "{{ entity.name }}" : "{{ entity.name_plural }}", e.what() ) );
    }
    catch( const std::exception& e )
    {
        throw ARQException( std::format( "Error invoking gRPC RefDataReader::get{} function: {}", singleFetch ? "{{ entity.name }}" : "{{ entity.name_plural }}", e.what() ) );
    }

    Log( Module::GRPC ).debug( "Completed gRPC RefDataReader::get{} function call in {}", singleFetch ? "{{ entity.name }}" : "{{ entity.name_plural }}", tm.duration() );

    return results;
}

std::vector<RDEntities::{{ entity.name }}> GrpcRefDataSource::fetch{{ entity.name_plural }}()
{
    return internalFetch{{ entity.name_plural }}( m_dsh );
}

std::optional<RDEntities::{{ entity.name }}> GrpcRefDataSource::fetch{{ entity.name }}( const RDEntities::Traits<RDEntities::{{ entity.name }}>::KeyType& {{ entity.key }} )
{
    auto result = internalFetch{{ entity.name_plural }}( m_dsh, {{ entity.key }} );
    return result.empty() ? std::nullopt : std::make_optional( std::move( result.front() ) );
}

// TODO: Need to implement fetchAsOf{{ entity.name_plural }} in a similar manner
// TODO: Need to create some audit load capability

[[nodiscard]] std::vector<RDEntities::{{ entity.name }}> GrpcRefDataSource::fetchAsOf{{ entity.name_plural }}( const Time::DateTime asof )
{
    return std::vector<RDEntities::{{ entity.name }}>();
}

void GrpcRefDataSource::upsert{{ entity.name_plural }}( const std::vector<RDEntities::{{ entity.name }}>& data )
{
    Instr::Timer tm;

    try
    {
        std::shared_ptr<grpc::Channel> channel = ChannelManager::inst().get( m_dsh, "RefDataGatekeeper" );

        ARQ::Grpc::RefData::RefDataGatekeeperClient client( channel );
        client.upsert{{ entity.name_plural }}( data );
    }
    catch( const ARQException& e )
    {
        throw ARQException( std::format( "Error invoking gRPC RefDataGatekeeper::upsert{{ entity.name_plural }} function: {}", e.what() ) );
    }
    catch( const std::exception& e )
    {
        throw ARQException( std::format( "Error invoking gRPC RefDataGatekeeper::upsert{{ entity.name_plural }} function: {}", e.what() ) );
    }

    Log( Module::GRPC ).debug( "Completed gRPC RefDataGatekeeper::upsert{{ entity.name_plural }} function call in {}", tm.duration() );
}

{% endfor %}

}