{#
  // codegen-metadata
  // output_path: ARQLib/ARQCore/inc/refdata_repository.h
#}
// THIS FILE IS AUTO-GENERATED BY THE CODE-GEN SCRIPT. DO NOT EDIT.
// Contains the Repository class and its cache for Reference Data entities..

#pragma once
#include <ARQCore/dll.h>

#include <ARQUtils/hashers.h>
#include <ARQCore/refdata_entities.h>
#include <ARQUtils/logger.h>
#include <ARQCore/refdata_source.h>

#include <unordered_map>
#include <vector>
#include <optional>
#include <atomic>
#include <memory>
#include <algorithm>

namespace ARQ::RD
{

// Forward declarations
class Repository;
template<c_RefData T> class Cache;
template<c_RefData T> void buildCacheIndexes( Cache<T>& cache );

template<c_RefData T>
class Cache
{
public:
    using RecordMap = std::unordered_map<ID::UUID, Record<T>>;

public:
    explicit Cache( std::vector<Record<T>>&& records )
    {
        for( const auto& record : records )
            m_map.emplace( record.header.uuid, std::move( record ) );

		buildCacheIndexes<T>( *this );
    }

    [[nodiscard]] const RecordMap& getAllRecords() const
    {
        return m_map;
    }

    [[nodiscard]] bool empty() const
    {
        return m_map.empty();
    }

    [[nodiscard]] size_t size() const
    {
        return m_map.size();
    }

    [[nodiscard]] std::optional<std::reference_wrapper<const Record<T>>> getRecord( const ID::UUID& id ) const
    {
        const auto it = m_map.find( id );
        if( it == m_map.end() )
            return std::nullopt;

        return std::cref( it->second );
    }

    [[nodiscard]] std::optional<std::reference_wrapper<const T>> get( const ID::UUID& id ) const
    {
        auto recordOpt = getRecord( id );
		return recordOpt ? std::make_optional( std::cref( recordOpt->get().data ) ) : std::nullopt;
    }

    [[nodiscard]] std::optional<std::reference_wrapper<const Record<T>>> getRecordByIndex( const std::string_view indexName, const std::string_view indexValue ) const
    {
		const auto it = std::find( m_uniqueIndices.begin(), m_uniqueIndices.end(), [&] ( const auto& pair ) { return pair.first == indexName; } );
		if( it == m_uniqueIndices.end() )
			throw ARQException( std::format( "Cache::getRecordByIndex: Given field [{}] is not a unique index for RefData entity [{}]", indexName, Traits<T>::name() ) );

		const UniqueIndexMap& indexMap = it->second;
		const auto indexIt = indexMap.find( indexValue );
		if( indexIt == indexMap.end() )
			return std::nullopt;
        
        return getRecord( indexIt->second );
    }

    [[nodiscard]] std::optional<std::reference_wrapper<const T>> getByIndex( const std::string_view indexName, const std::string_view indexValue ) const
    {
        auto recordOpt = getRecordByIndex( indexName, indexValue );
        return recordOpt ? std::make_optional( std::cref( recordOpt->get().data ) ) : std::nullopt;
    }

    [[nodiscard]] std::vector<std::reference_wrapper<const Record<T>>> getRecordsByNonUniqIndex( const std::string_view indexName, const std::string_view indexValue ) const
    {
        const auto it = std::find( m_nonUniqueIndices.begin(), m_nonUniqueIndices.end(), [&] ( const auto& pair ) { return pair.first == indexName; } );
        if( it == m_nonUniqueIndices.end() )
            throw ARQException( std::format( "Cache::getRecordsByNonUniqIndex: Given field [{}] is not a non-unique index for RefData entity [{}]", indexName, Traits<T>::name() ) );

        std::vector<std::reference_wrapper<const Record<T>>> results;
        
        const NonUniqueIndexMap& indexMap = it->second;
        const auto indexIt = indexMap.find( indexValue );
        if( indexIt != indexMap.end() )
        {
            for( const auto& id : indexIt->second )
            {
                auto recordOpt = getRecord( id );
                if( recordOpt )
                    results.push_back( std::cref( recordOpt->get() ) );
            }
        }

		return results;
    }

    [[nodiscard]] std::vector<std::reference_wrapper<const T>> getByNonUniqIndex( const std::string_view indexName, const std::string_view indexValue ) const
    {
        auto records = getRecordsByNonUniqIndex( indexName, indexValue );

        std::vector<std::reference_wrapper<const T>> results;
		for( const auto& recordRef : records )
			results.push_back( std::cref( recordRef.get().data ) );

		return results;
    }

private:
	using UniqueIndexMap    = std::unordered_map<std::string_view, ID::UUID>;
	using NonUniqueIndexMap = std::unordered_map<std::string_view, std::vector<ID::UUID>>;
    using UniqueIndices     = std::vector<std::pair<std::string_view, UniqueIndexMap>>;
    using NonUniqueIndices  = std::vector<std::pair<std::string_view, NonUniqueIndexMap>>;

private:
    RecordMap        m_map;
	UniqueIndices    m_uniqueIndices;
	NonUniqueIndices m_nonUniqueIndices;

private:
	friend void buildCacheIndexes<T>( Cache<T>& cache );
};

template<c_RefData T>
inline void buildCacheIndexes( Cache<T>& cache )
{
    // Default implementation does nothing
}

{% for entity in entities %}
{% if entity.has_indices %}
template<>
inline void buildCacheIndexes( Cache<{{ entity.name }}>& cache )
{
    {% for member in entity.members %}
    {% if member.index_type == 'Unique' %}
    Cache<{{ entity.name }}>::UniqueIndexMap& {{ member.name }}UniqIndex = cache.m_uniqueIndices.emplace_back( "{{ member.name }}", Cache<{{ entity.name }}>::UniqueIndexMap() ).second;
    {% endif %}
    {% if member.index_type == 'NonUnique' %}
    Cache<{{ entity.name }}>::NonUniqueIndexMap& {{ member.name }}NonUniqIndex = cache.m_nonUniqueIndices.emplace_back( "{{ member.name }}", Cache<{{ entity.name }}>::NonUniqueIndexMap() ).second;
    {% endif %}
    {% endfor %}
    
    for( const auto& [id, record] : cache.m_map )
    {
        {% for member in entity.members %}
        {% if member.index_type == 'Unique' %}
        {{ member.name }}UniqIndex.emplace( record.data.{{ member.name }}, id );
        {% endif %}
        {% if member.index_type == 'NonUnique' %}
        {{ member.name }}NonUniqIndex[record.data.{{ member.name }}].push_back( id );
        {% endif %}
        {% endfor %}
    }   
}
{% endif %}

{% endfor %}
class Repository
{
public:
    Repository( const std::string_view dsh )
	    : m_rdSource( SourceFactory::create( dsh ) )
    {}

	template<c_RefData T>
    std::shared_ptr<Cache<T>> get() const
    {
        {% for entity in entities %}
        if constexpr( std::is_same_v<T, {{ entity.name }}> )
        {
            if( !m_{{ entity.name_plural }}.load() )
                const_cast<Repository*>(this)->load<{{ entity.name }}>();
            return m_{{ entity.name_plural }};
        }
        {% endfor %}
    }

	template<c_RefData T>
    void load()
    {
        Log( Module::REFDATA ).info( "RD::Repository: Loading Reference Data for entity [{}]...", Traits<T>::name() );

        std::vector<Record<T>> records = m_rdSource->fetch<T>();
        std::shared_ptr<Cache<T>> newCache = std::make_shared<Cache<T>>( std::move( records ) );

        {% for entity in entities %}
        if constexpr( std::is_same_v<T, {{ entity.name }}> ) m_{{ entity.name_plural }}.store( newCache );
        {% endfor %}

        Log( Module::REFDATA ).info( "RD::Repository: Finished loading Reference Data for entity [{}]", Traits<T>::name() );
    }

private:
    std::shared_ptr<Source> m_rdSource;

    {% for entity in entities %}
    std::atomic<std::shared_ptr<Cache<{{ entity.name }}>>> m_{{ entity.name_plural }};
    {% endfor %}
};

}