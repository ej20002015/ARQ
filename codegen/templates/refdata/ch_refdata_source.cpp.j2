{#
  // codegen-metadata
  // output_path: ARQLib/ARQClickHouse/src/ch_refdata_source.cpp
#}
// THIS FILE IS AUTO-GENERATED BY THE CODE-GEN SCRIPT. DO NOT EDIT.
// Contains the implementation of the RefData ClickHouse EntitySource classes.

#include <ARQClickHouse/ch_refdata_source.h>

#include <ARQUtils/error.h>
#include <ARQUtils/instr.h>
#include <ARQCore/logger.h>

#include "connection.h"

#include <clickhouse/client.h>

namespace ARQ::CH::RD
{

void registerEntitySources( ARQ::RD::Source& source )
{
    {% for entity in entities %}
	source.registerEntitySource<ARQ::RD::{{ entity.name }}>( std::make_unique<CHEntitySource_{{ entity.name }}>() );
    {% endfor %}
}

static clickhouse::UUID toClickHouseUUID( const ID::UUID& arqUUID )
{
    clickhouse::UUID clickHouseUUID;
    std::memcpy( &clickHouseUUID.first, arqUUID.bytes.data(), 8 );
    std::memcpy( &clickHouseUUID.second, arqUUID.bytes.data() + 8, 8 );
    return clickHouseUUID;
}

static ID::UUID toArqUUID( const clickhouse::UUID& clickHouseUUID )
{
    ARQ::ID::UUID arqUUID;
    std::memcpy( arqUUID.bytes.data(), &clickHouseUUID.first, 8 );
    std::memcpy( arqUUID.bytes.data() + 8, &clickHouseUUID.second, 8 );
    return arqUUID;
}

{% for entity in entities %}
// --- Implementation for {{ entity.name }} ---

std::vector<ARQ::RD::Record<ARQ::RD::{{ entity.name }}>> CHEntitySource_{{ entity.name }}::fetch() const
{
    CHConn conn( dsh() );

    std::vector<ARQ::RD::Record<ARQ::RD::{{ entity.name }}>> results;

    Instr::Timer tm;

    static constexpr auto SELECT_STMT = R"(
		SELECT
            UUID,
            {% for member in entity.members %}
            {% if member.name != entity.key %}
            argMax({{ member.name | capitalise_first }}, _LastUpdatedTs) AS max_{{ member.name | capitalise_first }},
            {% endif %}
            {% endfor %}
            argMax(_IsActive, _LastUpdatedTs) AS max_IsActive,
            max(_LastUpdatedTs) AS max_LastUpdatedTs,
            argMax(_LastUpdatedBy, _LastUpdatedTs) AS max_LastUpdatedBy,
            argMax(_Version, _LastUpdatedTs) AS max_Version
		FROM RefData.{{ entity.table_name }}
        GROUP BY UUID
		HAVING max_IsActive = 1;
	)";

    try
    {
        conn.client().Select( SELECT_STMT, [&] ( const clickhouse::Block& block )
        {
            if( block.GetRowCount() == 0 )
                return; // End of data

			auto col_uuid = block[0]->As<clickhouse::ColumnUUID>();
            {% for member in entity.members %}
            auto col_{{ member.name }} = block[{{ loop.index0 + 1 }}]->As<clickhouse::Column{{ types[member.type].clickhouse}}>();
            {% endfor %}
            auto col_isActive = block[{{ entity.members | length + 1 }}]->As<clickhouse::ColumnUInt8>();
            auto col_lastUpdatedTs = block[{{ entity.members | length + 2 }}]->As<clickhouse::ColumnDateTime64>();
            auto col_lastUpdatedBy = block[{{ entity.members | length + 3 }}]->As<clickhouse::ColumnString>();
            auto col_Version = block[{{ entity.members | length + 4 }}]->As<clickhouse::ColumnUInt32>();

            results.reserve( results.size() + block.GetRowCount() );
            for( size_t i = 0; i < block.GetRowCount(); ++i )
            {
                ARQ::RD::Record<ARQ::RD::{{ entity.name }}> obj;
				obj.data.uuid = toArqUUID( col_uuid->At( i ) );
				obj.header.uuid =  obj.data.uuid;
                {% for member in entity.members %}
                {% if types[member.type].clickhouse == "DateTime64(6)" %}
                obj.data.{{ member.name }} = Time::DateTime( Time::Microseconds( col_{{ member.name }}->At( i ) ) );
                {% else %}
                obj.data.{{ member.name }} = col_{{ member.name }}->At( i );
                {% endif %}
                {%- endfor %}
                obj.header.isActive = col_isActive->At( i );
                obj.header.lastUpdatedTs = Time::DateTime( Time::Microseconds( col_lastUpdatedTs->At( i ) ) );
                obj.header.lastUpdatedBy = col_lastUpdatedBy->At( i );
                obj.header.version = col_Version->At( i );
                results.push_back( std::move( obj ) );
            }
        } );
    }
    catch( const std::exception& e )
    {
        throw ARQException( std::format( "Error executing ClickHouse SELECT query: {}", e.what() ) );
    }

    Log( Module::CLICKHOUSE ).debug( "Ran ClickHouse select query in {}", tm.duration() );

    return results;
}

void CHEntitySource_{{ entity.name }}::insert( const std::vector<ARQ::RD::Record<ARQ::RD::{{ entity.name }}>>& data )
{
    CHConn conn( dsh() );

    Instr::Timer tm;

    try
    {
		auto col_uuid = std::make_shared<clickhouse::ColumnUUID>();
        {% for member in entity.members %}
        {% if types[member.type].clickhouse == "DateTime64(6)" %}
        auto col_{{ member.name }} = std::make_shared<clickhouse::ColumnDateTime64>( 6 );
        {% else %}
        auto col_{{ member.name }} = std::make_shared<clickhouse::Column{{ types[member.type].clickhouse }}>();
        {% endif %}
        {% endfor %}
        auto col_isActive = std::make_shared<clickhouse::ColumnUInt8>();
		auto col_lastUpdatedTs = std::make_shared<clickhouse::ColumnDateTime64>( 6 );
        auto col_lastUpdatedBy = std::make_shared<clickhouse::ColumnString>();
        auto col_Version = std::make_shared<clickhouse::ColumnUInt32>();

        col_uuid->Reserve( data.size() );
        {% for member in entity.members %}
        col_{{ member.name }}->Reserve( data.size() );
        {% endfor %}
		col_isActive->Reserve( data.size() );
		col_lastUpdatedTs->Reserve( data.size() );
		col_lastUpdatedBy->Reserve( data.size() );
		col_Version->Reserve( data.size() );

        for( const auto& obj : data )
        {
			col_uuid->Append( toClickHouseUUID( obj.header.uuid ) );
            {% for member in entity.members %}
            {% if types[member.type].clickhouse == "DateTime64(6)" %}
            col_{{ member.name }}->Append( obj.data.{{ member.name }}.microsecondsSinceEpoch() );
            {% else %}
            col_{{ member.name }}->Append( obj.data.{{ member.name }} );
            {% endif %}
            {% endfor %}
            col_isActive->Append( obj.header.isActive );
			col_lastUpdatedTs->Append( obj.header.lastUpdatedTs.microsecondsSinceEpoch() );
            col_lastUpdatedBy->Append( obj.header.lastUpdatedBy );
            col_Version->Append( obj.header.version );
        }

        clickhouse::Block block;
		block.AppendColumn( "UUID", col_uuid );
        {% for member in entity.members %}
        block.AppendColumn( "{{ member.name | capitalise_first }}", col_{{ member.name }} );
        {% endfor %}
        block.AppendColumn( "_IsActive", col_isActive );
        block.AppendColumn( "_LastUpdatedBy", col_lastUpdatedBy );
		block.AppendColumn( "_LastUpdatedTs", col_lastUpdatedTs );
        block.AppendColumn( "_Version", col_Version );

        conn.client().Insert( "RefData.{{ entity.table_name }}", block );
    }
    catch( const std::exception& e )
    {
        throw ARQException( std::format( "Error executing ClickHouse INSERT query: {0}", e.what() ) );
    }

    Log( Module::CLICKHOUSE ).debug( "Ran ClickHouse insert query in {}", tm.duration() );
}

{% endfor %}
}