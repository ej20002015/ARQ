{#
  // codegen-metadata
  // output_path: ARQLib/ARQCore/src/refdata_manager.cpp
#}
// THIS FILE IS AUTO-GENERATED BY THE CODE-GEN SCRIPT. DO NOT EDIT.
// Contains implementation of the RefDataManager class.

#include <ARQCore/refdata_manager.h>

namespace ARQ
{

{% for entity in entities %}
// --- Implementation for {{ entity.name }} ({{ entity.type_string }}) ---

[[nodiscard]] bool RefDataManager::has{{ entity.name_plural }}() const
{
    std::shared_lock<std::shared_mutex> sl( m_mut );
    return m_{{ entity.name_plural }} != nullptr;
}

[[nodiscard]] std::shared_ptr<RefDataCache<RDEntities::{{ entity.name }}>> RefDataManager::{{ entity.name_plural }}() const
{
    if( !has{{ entity.name_plural }}() )
        const_cast<RefDataManager*>( this )->loadInitially{{ entity.name_plural }}();

	return m_{{ entity.name_plural }};
}

void RefDataManager::reload{{ entity.name_plural }}()
{
    Log( Module::REFDATA ).debug( "RefDataManager: Reloading {} data", RDEntities::Traits<RDEntities::{{ entity.name }}>::name() );

    std::map<RDEntities::Traits<RDEntities::{{ entity.name }}>::KeyType, RDEntities::{{ entity.name }}> newData;
    auto objs = m_rdSource->fetch{{ entity.name_plural }}();
    for( auto&& obj : std::move( objs ) )
        newData.emplace( obj.{{ entity.key}}, std::move( obj ) );

    std::unique_lock<std::shared_mutex> ul( m_mut );
    m_{{ entity.name_plural }} = std::make_shared<RefDataCache<RDEntities::{{ entity.name }}>>( std::move( newData ) );

    Log( Module::REFDATA ).debug( "RefDataManager: Reloaded {} data, count: {}", RDEntities::Traits<RDEntities::{{ entity.name }}>::name(), m_{{ entity.name_plural }}->m_map.size() );
}

void RefDataManager::loadInitially{{ entity.name_plural }}()
{
	std::unique_lock<std::shared_mutex> ul( m_mut );

	if( m_{{ entity.name_plural }} )
	{
		Log( Module::REFDATA ).debug( "RefDataManager: Skipping initial load - already loaded {} data, count: {}", RDEntities::Traits<RDEntities::{{ entity.name }}>::name(), m_{{ entity.name_plural }}->m_map.size() );
		return;
	}

	Log( Module::REFDATA ).debug( "RefDataManager: Doing initial load of {} data", RDEntities::Traits<RDEntities::{{ entity.name }}>::name() );

    std::map<RDEntities::Traits<RDEntities::{{ entity.name }}>::KeyType, RDEntities::{{ entity.name }}> newData;
    auto objs = m_rdSource->fetch{{ entity.name_plural }}();
    for( auto&& obj : std::move( objs ) )
        newData.emplace( obj.{{ entity.key}}, std::move( obj ) );

    m_{{ entity.name_plural }} = std::make_shared<RefDataCache<RDEntities::{{ entity.name }}>>( std::move( newData ) );

    Log( Module::REFDATA ).debug( "RefDataManager: Completed initial load of {} data, count: {}", RDEntities::Traits<RDEntities::{{ entity.name }}>::name(), m_{{ entity.name_plural }}->m_map.size() );
}

void RefDataManager::insert{{ entity.name_plural }}( const std::vector<RDEntities::{{ entity.name }}>& data, const StaleCheck staleCheck )
{
    Log( Module::REFDATA ).info( "RefDataManager: Inserting {} data, count: {}", RDEntities::Traits<RDEntities::{{ entity.name }}>::name(), data.size() );

    if( staleCheck == USING_CACHE || staleCheck == USING_DB ) // TODO: Should be checking this as part of the DB transaction
    {
		if( !has{{ entity.name_plural }}() )
			loadInitially{{ entity.name_plural }}();
		else if( staleCheck == USING_DB )
			reload{{ entity.name_plural }}();

        auto rdCache = m_{{ entity.name_plural }};

        for( const RDEntities::{{ entity.name }}& dataItem : data )
        {
            const auto cachedItem = rdCache->get( dataItem.{{ entity.key }} );
            if( cachedItem && cachedItem->get()._lastUpdatedTs > dataItem._lastUpdatedTs )
            {
                throw ARQException( std::format( "RefDataManager: Not inserting refdata due to stale record for {}.{} - ts of record to insert is {}; ts of record in cache is {}",
                                                  RDEntities::Traits<RDEntities::{{ entity.name }}>::name(), dataItem.{{ entity.key }}, dataItem._lastUpdatedTs, cachedItem->get()._lastUpdatedTs ) );
            }
        }
    }

    m_rdSource->upsert{{ entity.name_plural }}( data );

    Log( Module::REFDATA ).info( "RefDataManager: Inserted {} data, count: {}", RDEntities::Traits<RDEntities::{{ entity.name }}>::name(), data.size() );

    // Reload the cache after insertion
    reload{{ entity.name_plural }}();
}

void RefDataManager::insert{{ entity.name }}( const RDEntities::{{ entity.name }}& data, const StaleCheck staleCheck )
{
    insert{{ entity.name_plural }}( std::vector<RDEntities::{{ entity.name }}>{ data }, staleCheck );
}

{% endfor %}


}