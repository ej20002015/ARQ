{#
  // codegen-metadata
  // output_path: TMQLib/SWIG/TMQCore/generated_refdata_bindings.i
#}
// THIS FILE IS AUTO-GENERATED BY THE CODE-GEN SCRIPT. DO NOT EDIT.
// It is a self-contained SWIG interface for wrapping TMQ Reference Data entities.

//
//
//
// TODO: THIS ISN'T BEING USED YET AND WILL NEED TO BE ADJUSTED!
//
//
//
//
//

%module TMQRefDataCSharp

// --- 1. SWIG Setup and Standard Typemaps ---
%include "csharp/csharp.i"
%typemap(csimports) %{
using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
%}
%include "std_string.i"
%include "std_array.i"
%include "std_pair.i"
%include "std_optional.i"
%include "exception.i"

// --- 2. Custom Typemaps (e.g., for chrono, string_view) ---
// (Copy your proven typemaps for std::chrono, std::string_view, etc. here)
// Example for string_view:
%typemap(cstype) std::string_view "string";
%typemap(imtype) std::string_view "string";
%typemap(csout, excode=SWIGEXCODE) std::string_view {
    string csharpresult;
    if ($imcall.data() != null)
        csharpresult = new string($imcall.data(), 0, (int)$imcall.length());
    else
        csharpresult = null;
    return csharpresult;
}


// --- 3. C++ Includes for the Wrapper Implementation ---
// The generated C++ wrapper code needs to include the real C++ headers to compile.
%{
#include "refdata_entities.h" // The generated C++ header
// #include "TMQRefData/RefDataManager.h" // A hand-written header if wrapping it
%}


// --- 4. Inline C++ Declarations for SWIG Parsing ---
// Instead of %include-ing the header for SWIG to parse, we generate the
// definitions directly into this file. SWIG parses this section to create the wrappers.
namespace TMQ {

// Base struct and traits definitions (these are static, so can be here)
struct RefDataEntity {
    bool isActive;
    std::chrono::system_clock::time_point creationTimestamp;
};

template<typename T>
concept c_RefDataEntity = std::is_base_of_v<RefDataEntity, T>;

struct MemberInfo {
    const std::string_view name;
    const std::string_view comment;
    const std::string_view cpp_type;
    const std::string_view clickhouse_type;
    const std::string_view flatbuffer_type;
    const std::string_view csharp_type;
};

template<c_RefDataEntity T>
class RefDataEntityTraits { /* ... */ };


// Loop through entities to generate the C++ struct definitions for SWIG to see
{% for entity in entities %}
struct {{ entity.name }} : public RefDataEntity
{
    {% for member in entity.members -%}
    {%- set type_info = types[member.type] if member.type is string else member.type -%}
    {{ type_info.cpp }} {{ member.name }};
    {% endfor %}
};
{% endfor %}

// Also include any non-generated class definitions you want to wrap
// %include "TMQRefData/RefDataManager.h" // <-- Or place the class definition here too

} // namespace TMQ


// --- 5. SWIG Template Instantiations and Directives ---
// This part is the same as the previous refdata_metadata_bindings.i.j2 template

{% for entity in entities %}
// --- Bindings for {{ entity.name }} ---
%typemap(csclassmodifiers) TMQ::{{ entity.name }} "public partial";
%template(RefDataEntityTraits_{{ entity.name }}) TMQ::RefDataEntityTraits<TMQ::{{ entity.name }}>;
%template(MemberInfoArray_{{ entity.name }}) std::array<TMQ::MemberInfo, {{ entity.members | length }}>;
%template(Vector{{ entity.name }}) std::vector<TMQ::{{ entity.name }}>;
%template(Optional{{ entity.name }}) std::optional<TMQ::{{ entity.name }}>;
{% endfor %}