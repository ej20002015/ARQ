{#
  // codegen-metadata
  // output_path: ARQLib/ARQProtobuf/src/proto_refdata_type_serialisers.cpp
#}
// THIS FILE IS AUTO-GENERATED BY THE CODE-GEN SCRIPT. DO NOT EDIT.
// Contains (de)serialisation code for refdata entities and commands

#include "proto_refdata_type_serialisers.h"

#include "proto_gen/refdata.pb.h"

namespace ARQ
{

void registerRefDataSerialisers( Serialiser& serialiser )
{
    {% for entity in entities %}
    serialiser.registerHandler<RDCommands::Upsert{{ entity.name_plural }}>( std::make_unique<ProtobufTypeSerialiser_Upsert{{ entity.name_plural }}>() );
    serialiser.registerHandler<RDCommands::Deactivate{{ entity.name_plural }}>( std::make_unique<ProtobufTypeSerialiser_Deactivate{{ entity.name_plural }}>() );
    {% endfor %}
}

/*
================== Helpers ==================
*/

{% for entity in entities %}
void toProto( const RDEntities::{{ entity.name }} arqEntity, ARQ::Proto::RefData::{{ entity.name }}* protoEntity )
{
    protoEntity->set__is_active( arqEntity._isActive );
    protoEntity->set__last_updated_ts( arqEntity._lastUpdatedTs.microsecondsSinceEpoch() );
    protoEntity->set__last_updated_by( std::move( arqEntity._lastUpdatedBy ) );
    protoEntity->set__version( arqEntity._version );

    {{ entity.name }}Payload* const payload = grpcEntity->mutable_payload();
    {% for member in entity.members %}
    {% if member.type == "datetime" %}
    payload->set_{{ member.name | snake_case }}( arqEntity.{{ member.name }}.microsecondsSinceEpoch() );
    {% else %}
    payload->set_{{ member.name | snake_case }}( arqEntity.{{ member.name }} );
    {% endif %}
    {% endfor %}
}

{% endfor %}

/*
================== Type Serialisers ==================
*/

{% for entity in entities %}
// --- Commands for {{ entity.name }} ({{ entity.type_string }}) ---

Buffer ProtobufTypeSerialiser_Upsert{{ entity.name_plural }}::serialise( const RDCommands::Upsert{{ entity.name_plural }}& obj ) const
{
    ARQ::Proto::RefData::Upsert{{ entity.name_plural }}Command protoObj;

    for( const auto& item : obj.items )
    {
        ARQ::Proto::RefData::Upsert{{ entity.name_plural }}Command::Item* const protoItemPtr = request.add_items();
        protoItemPtr->set_expected_version( item.expectedVersion );
        protoItemPtr->set_updated_by( item.updatedBy );
        ARQ::Proto::RefData::{{ entity.name }}* const protoEntity = protoItemPtr->mutable_{{ entity.name | snake_case }}();
        toProto( item.{{ entity.name | camel_case }}, protoEntity );
    }

    Buffer protoBuf( protoObj.ByteSizeLong() );
	protoObj.SerializeToArray( protoBuf.data.get(), protoBuf.size );
	return protoBuf;
}

void ProtobufTypeSerialiser_Upsert{{ entity.name_plural }}::deserialise( const BufferView buf, RDCommands::Upsert{{ entity.name_plural }}& objOut ) const
{
    ARQ::Proto::RefData::Upsert{{ entity.name_plural }}Command protoObj;    
    resp.ParseFromArray( buf.data, buf.size );

    const size_t numUpsertItems = request->items_size();
    for( size_t i = 0; i < numUpsertItems; ++i )
    {
        
    }
}

{% endfor %}

Buffer ProtobufTypeSerialiser_RefDataCommandResponse::serialise( const RefDataCommandResponse& obj ) const
{
	ARQ::Proto::RefDataCommandResponse resp;

	ARQ::Proto::ID::UUID* uuidPtr = resp.mutable_corr_id();
	std::string* uuidBufPtr = uuidPtr->mutable_id();
	*uuidBufPtr = obj.corrID.toString();

	resp.set_status( Enum::enum_integer( obj.status ) );
	if( obj.message )
		resp.set_message( *obj.message );

	Buffer respBuf( resp.ByteSizeLong() );
	resp.SerializeToArray( respBuf.data.get(), respBuf.size );
	return respBuf;
}

void ProtobufTypeSerialiser_RefDataCommandResponse::deserialise( const BufferView buf, RefDataCommandResponse& objOut ) const
{
	ARQ::Proto::RefDataCommandResponse resp;
	resp.ParseFromArray( buf.data, buf.size );

	objOut.corrID = ID::UUID::fromString( resp.corr_id().id() );
	const auto statusOpt = Enum::enum_cast<RefDataCommandResponse::Status>( resp.status() );
	if( statusOpt )
		objOut.status = statusOpt.value();
	else
		throw ARQException( std::format( "Cannot deserialise buffer into RefDataCommandResponse - status integer [{}] not a value in RefDataCommandResponse::Status enum", resp.status() ) );
	if( resp.has_message() )
		objOut.message = resp.message();
}

}