{#
  // codegen-metadata
  // output_path: ARQLib/ARQCore/src/refdata_repository.cpp
#}
// THIS FILE IS AUTO-GENERATED BY THE CODE-GEN SCRIPT. DO NOT EDIT.
// Contains the Repository class and its cache for Reference Data entities.

#include <ARQCore/refdata_repository.h>

namespace ARQ::RD
{

{% for entity in entities %}
// --- Implementation for {{ entity.name }} ({{ entity.type_string }}) ---

[[nodiscard]] bool Repository::has{{ entity.name_plural }}() const
{
    std::shared_lock<std::shared_mutex> sl( m_mut );
    return m_{{ entity.name_plural }} != nullptr;
}

[[nodiscard]] std::shared_ptr<Cache<{{ entity.name }}>> Repository::{{ entity.name_plural }}() const
{
    if( !has{{ entity.name_plural }}() )
        const_cast<Repository*>( this )->loadInitially{{ entity.name_plural }}();

	return m_{{ entity.name_plural }};
}

void Repository::reload{{ entity.name_plural }}()
{
    Log( Module::REFDATA ).debug( "Repository: Reloading {} data", Traits<{{ entity.name }}>::name() );

    std::map<ID::UUID, {{ entity.name }}> newData;
    auto objs = m_rdSource->fetch{{ entity.name_plural }}();
    for( auto&& obj : std::move( objs ) )
        newData.emplace( obj.uuid, std::move( obj ) );

    std::unique_lock<std::shared_mutex> ul( m_mut );
    m_{{ entity.name_plural }} = std::make_shared<Cache<{{ entity.name }}>>( std::move( newData ) );

    Log( Module::REFDATA ).debug( "Repository: Reloaded {} data, count: {}", Traits<{{ entity.name }}>::name(), m_{{ entity.name_plural }}->m_map.size() );
}

void Repository::loadInitially{{ entity.name_plural }}()
{
	std::unique_lock<std::shared_mutex> ul( m_mut );

	if( m_{{ entity.name_plural }} )
	{
		Log( Module::REFDATA ).debug( "Repository: Skipping initial load - already loaded {} data, count: {}", Traits<{{ entity.name }}>::name(), m_{{ entity.name_plural }}->m_map.size() );
		return;
	}

	Log( Module::REFDATA ).debug( "Repository: Doing initial load of {} data", Traits<{{ entity.name }}>::name() );

    std::map<ID::UUID, {{ entity.name }}> newData;
    auto objs = m_rdSource->fetch{{ entity.name_plural }}();
    for( auto&& obj : std::move( objs ) )
        newData.emplace( obj.uuid, std::move( obj ) );

    m_{{ entity.name_plural }} = std::make_shared<Cache<{{ entity.name }}>>( std::move( newData ) );

    Log( Module::REFDATA ).debug( "Repository: Completed initial load of {} data, count: {}", Traits<{{ entity.name }}>::name(), m_{{ entity.name_plural }}->m_map.size() );
}

{% endfor %}
}