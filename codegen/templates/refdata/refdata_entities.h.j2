{#
  // codegen-metadata
  // output_path: TMQLib/TMQCore/inc/refdata_entities.h
#}
// THIS FILE IS AUTO-GENERATED BY THE CODE-GEN SCRIPT. DO NOT EDIT.
// Contains C++ definitions for Reference Data entities.

#pragma once

#include <string>
#include <chrono>
#include <cstdint>
#include <concepts>
#include <string_view>
#include <array>
#include <utility>
#include <optional>

namespace TMQ
{
namespace RDEntities
{

/*
********************************************
* Base Class and Traits for Reference Data *
********************************************
*/

// Base struct for all reference data entities
struct RDEntity
{
    bool _isActive = true;
    std::chrono::system_clock::time_point _lastUpdatedTs;
    std::string _lastUpdatedBy;
};

template<typename T>
concept c_RDEntity = std::is_base_of_v<RDEntity, T>;

// Traits class to get compile-time metadata about an entity
template<c_RDEntity T>
class Traits
{
public:
    static consteval std::string_view const name()      { static_assert( false, "Missing RDEntities::Traits specialization for this type" ); return ""; }
    static consteval std::string_view const type()      { static_assert( false, "Missing RDEntities::Traits specialization for this type" ); return ""; }
    static consteval std::string_view const tableName() { static_assert( false, "Missing RDEntities::Traits specialization for this type" ); return ""; }
    static consteval std::string_view const key()       { static_assert( false, "Missing RDEntities::Traits specialization for this type" ); return ""; }
};

struct MemberInfo
{
    const std::string_view name;           // Name of the C++ member variable
    const std::string_view comment;        // Documentation string
    const std::string_view type;           // The language agnostic type as a string
    const std::string_view cppType;        // The C++ type as a string
    const std::string_view clickhouseType; // The ClickHouse type as a string
    const std::string_view flatbufferType; // The FlatBuffers type as a string
};

/*
********************************************
*            Entity Definitions            *
********************************************
*/

{# We loop over each entity defined in the TOML file #}
{% for entity in entities %}

/// {{ entity.comment | default('Represents ' + entity.name + ' reference data.') }}
struct {{ entity.name }} : public RDEntity
{
    {# Loop over the members of the current entity #}
    {% for member in entity.members -%}
    {% if member.comment %}    /// {{ member.comment }}
    {% endif %}
    {{ types[member.type].cpp }} {{ member.name }};
    {% endfor %}
};

// Traits specialization for {{ entity.name }}
template<>
class Traits<{{ entity.name }}>
{
public:
    static consteval std::string_view const name()      { return "{{ entity.name }}"; }
    static consteval std::string_view const type()      { return "{{ entity.type_string }}"; }
    static consteval std::string_view const tableName() { return "{{ entity.table_name }}"; }
    static consteval std::string_view const key()       { return "{{ entity.key }}"; }

    using KeyType = {{ types[entity.key_type].cpp }};

    // A compile-time array holding metadata for all members.
    static constexpr std::array<MemberInfo, {{ entity.members | length }}> membersInfo =
    {{ '{' }}
        {% for member in entity.members %}
        MemberInfo {
            /*name            = */ "{{ member.name }}",
            /*comment         = */ "{{ member.comment | default('') }}",
            /*type            = */ "{{ member.type }}",
            /*cpp_type        = */ "{{ types[member.type].cpp }}",
            /*clickhouse_type = */ "{{ types[member.type].clickhouse }}",
            /*flatbuffer_type = */ "{{ types[member.type].flatbuffer }}"
        }{% if not loop.last %},
        {% endif %}
        {% endfor %}
    
    {{ '}' }};

    // A compile-time helper function to look up info for a specific member.
    static consteval std::optional<MemberInfo> getMemberInfo( const std::string_view memberName )
    {
        for( const auto& info : membersInfo )
        {
            if( info.name == memberName )
                return info;
        }
        return std::nullopt;
    }
};

{% endfor %}
}
}