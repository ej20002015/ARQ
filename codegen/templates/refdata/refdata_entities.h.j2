{#
  // codegen-metadata
  // output_path: ARQLib/ARQCore/inc/refdata_entities.h
#}
// THIS FILE IS AUTO-GENERATED BY THE CODE-GEN SCRIPT. DO NOT EDIT.
// Contains C++ definitions for Reference Data entities.

#pragma once

#include <ARQUtils/core.h>
#include <ARQUtils/time.h>

#include <string>
#include <cstdint>
#include <concepts>
#include <string_view>
#include <array>
#include <utility>
#include <optional>

namespace ARQ
{
namespace RDEntities
{

/*
****************************************************
* Common functionality for Reference Data Entities *
****************************************************
*/

// Base struct for all reference data entities
struct RDEntity
{
    bool _isActive = true;
    Time::DateTime _lastUpdatedTs;
    std::string _lastUpdatedBy;
    uint32_t _version = 0;
};

template<typename T>
concept c_RDEntity = std::is_base_of_v<RDEntity, T>;

enum class Type
{
    _NOTSET_ = -1,
    {% for entity in entities %}
    {{ entity.type_string }},
    {% endfor %}
};

inline std::string_view typeToStr( const Type type)
{
    switch( type )
    {
        {% for entity in entities %}
        case Type::{{ entity.type_string }}: return "{{ entity.type_string }}";
        {% endfor %}
        default:
            ARQ_ASSERT( false ); return "Unknown";
    }
}

// Traits class to get compile-time metadata about an entity
template<c_RDEntity T>
class Traits
{
public:
    static constexpr std::string_view const name()      { static_assert( false, "Missing RDEntities::Traits specialization for this type" ); return ""; }
    static constexpr std::string_view const type()      { static_assert( false, "Missing RDEntities::Traits specialization for this type" ); return ""; }
    static constexpr std::string_view const tableName() { static_assert( false, "Missing RDEntities::Traits specialization for this type" ); return ""; }
    static constexpr Type             const typeEnum()  { static_assert( false, "Missing RDEntities::Traits specialization for this type" ); return Type::USER; }
    static constexpr std::string_view const key()       { static_assert( false, "Missing RDEntities::Traits specialization for this type" ); return ""; }
};

struct MemberInfo
{
    /// Name of the C++ member variable
    std::string_view name;
    /// Documentation string
    std::string_view comment;
    /// The language agnostic type as a string
    std::string_view type;
    /// The C++ type as a string
    std::string_view cppType;
    /// The ClickHouse type as a string
    std::string_view clickhouseType;
    /// The FlatBuffers type as a string
    std::string_view flatbufferType;
};

/*
********************************************
*            Entity Definitions            *
********************************************
*/

{# We loop over each entity defined in the TOML file #}
{% for entity in entities %}

/// {{ entity.comment | default('Represents ' + entity.name + ' reference data.') }}
struct {{ entity.name }} : public RDEntity
{
    {# Loop over the members of the current entity #}
    {% for member in entity.members -%}
    {% if member.comment %}    /// {{ member.comment }}
    {% endif %}
    {{ types[member.type].cpp }} {{ member.name }};
    {% endfor %}
};

// Traits specialization for {{ entity.name }}
template<>
class Traits<{{ entity.name }}>
{
public:
    static constexpr std::string_view const name()      { return "{{ entity.name }}"; }
    static constexpr std::string_view const type()      { return "{{ entity.type_string }}"; }
    static constexpr Type             const typeEnum()  { return Type::{{ entity.type_string }}; }
    static constexpr std::string_view const tableName() { return "{{ entity.table_name }}"; }
    static constexpr std::string_view const key()       { return "{{ entity.key }}"; }

    using KeyType = {{ types[entity.key_type].cpp }};

    static KeyType getKeyVal( const {{ entity.name }}& entity ) { return entity.{{ entity.key }}; }

    // A compile-time array holding metadata for all members.
    static constexpr std::array<MemberInfo, {{ entity.members | length }}> membersInfo =
    {{ '{' }}
        {% for member in entity.members %}
        MemberInfo {
            /*name            = */ "{{ member.name }}",
            /*comment         = */ "{{ member.comment | default('') }}",
            /*type            = */ "{{ member.type }}",
            /*cpp_type        = */ "{{ types[member.type].cpp }}",
            /*clickhouse_type = */ "{{ types[member.type].clickhouse }}",
            /*flatbuffer_type = */ "{{ types[member.type].flatbuffer }}"
        }{% if not loop.last %},
        {% endif %}
        {% endfor %}
    
    {{ '}' }};

    // A compile-time helper function to look up info for a specific member.
    static constexpr std::optional<MemberInfo> getMemberInfo( const std::string_view memberName )
    {
        for( const auto& info : membersInfo )
        {
            if( info.name == memberName )
                return info;
        }
        return std::nullopt;
    }
};

{% endfor %}
}
}