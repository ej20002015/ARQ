{#
  // codegen-metadata
  // output_path: ARQLib/ARQCore/inc/refdata_entities.h
#}
// THIS FILE IS AUTO-GENERATED BY THE CODE-GEN SCRIPT. DO NOT EDIT.
// Contains C++ definitions for Reference Data entities.

#pragma once

#include <ARQUtils/error.h>
#include <ARQUtils/types.h>
#include <ARQUtils/time.h>
#include <ARQUtils/id.h>
#include <ARQUtils/str.h>
#include <ARQUtils/tuple_vector.h>
#include <ARQCore/type_registry.h>

#include <string>
#include <cstdint>
#include <string_view>
#include <array>
#include <utility>

namespace ARQ::RD
{

#pragma region Common RefData Types

/*
*********************************************
*    Common types for RefData Entities      *
*********************************************
*/

ARQ_DEFINE_TYPE_CATEGORY( RefData );

// Traits class to get compile-time metadata about an entity
template<c_RefData T>
class Traits {};

enum class IndexType
{
    None,
    Unique,   // 1-to-1
    NonUnique // 1-to-Many
};

// Records metadata about each member in a RD type
struct MemberInfo
{
    /// Name of the C++ member variable
    std::string_view name;
    /// Documentation string
    std::string_view comment;
    /// The language agnostic type as a string
    std::string_view type;
    // Indicates if member is an index, and what type
    IndexType        indexType;
};

/// Metadata header common to all Reference Data records
struct RecordHeader
{
    /// The immutable, globally unique system identifier (Machine Key)
    ID::UUID       uuid;
    /// Indicates if the record is still active - false means it's been 'tombstoned'
    bool           isActive;
    /// The timestamp of the last successful commit
    Time::DateTime lastUpdatedTs;
    /// The user who last updated the record
    std::string    lastUpdatedBy;
    /// Optimistic Concurrency Control (OCC) version number
    uint32_t       version;
};

/// The generic storage container for all Reference Data entities
template<c_RefData T>
struct Record
{
    using EntityType = T;

    /// Entity metadata
    RecordHeader header;
    /// The actual entity data
    T            data;
};

#pragma endregion

#pragma region RefData Entities

/*
***********************************
* Definitions of RefData entities *
***********************************
*/

{% for entity in entities %}

// -------------------- {{ entity.name }} RefData entity --------------------

/// {{ entity.comment | default('Represents ' + entity.name + ' reference data.') }}
struct {{ entity.name }}
{
    /// The immutable, globally unique system identifier (Machine Key)
    ID::UUID uuid;
    {# Loop over the members of the current entity #}
    {% for member in entity.members -%}
    {% if member.comment %}    /// {{ member.comment }}
    {% endif %}
    {{ types[member.type].cpp }} {{ member.name }};
    {% endfor %}
};

ARQ_REG_CATEGORY( RefData, {{ entity.name }} )

template<>
class Traits<{{ entity.name }}>
{
public:
    static constexpr std::string_view const name() { return "{{ entity.name }}"; }

    static constexpr std::array<MemberInfo, {{ entity.members | length }}> membersInfo =
    {{ '{' }}
        {% for member in entity.members %}
        MemberInfo {
            .name      = "{{ member.name }}",
            .comment   = "{{ member.comment | default('') }}",
            .type      = "{{ member.type }}",
            .indexType = IndexType::{{ member.index_type | default('None') }}
        }{% if not loop.last %},
        {% endif %}
        {% endfor %}
    
    {{ '}' }};
};

{% endfor %}

#pragma endregion

#pragma region RefData Helpers

/*
*********************************************
*   Helper typedefs for RefData Entities    *
*********************************************
*/

using RecordCollection = TupleVector<
{% for entity in entities %}
    Record<{{ entity.name }}>{% if not loop.last %},{% endif %}
    
{% endfor %}
>;

/*
*********************************************
*   Helper functions for RefData Entities   *
*********************************************
*/

/**
 * @brief Dispatches to the concrete type T based on entity name.
 * @param entityName The name of the RefData entity.
 * @param visitor A callable object with a templated operator()<T>() method.
 * @param doThrow Whether to throw an exception on unknown entity name.
 * @returns whatever the visitor returns.
 * @throws ARQException if entityName is unknown.
 */
template<typename F>
decltype(auto) dispatch( const std::string_view entityName, F&& visitor, const DoThrow doThrow = DoThrow::YES )
{
    switch( Str::constexprHash( entityName ) )
    {
        {% for entity in entities %}
        case Str::constexprHash( "{{ entity.name }}" ):
            if (entityName == "{{ entity.name }}") 
                return visitor.template operator()<{{ entity.name }}>();
            break;
        {% endfor %}
    }

    if( doThrow == DoThrow::YES )
        throw ARQException( std::format( "Unknown RefData entity name [{}] - cannot dispatch to function", entityName ) );
}

#pragma endregion

}

#pragma region RefData Type Registration

// Must register outside namespace
{% for entity in entities %}
ARQ_REG_TYPE( ARQ::RD::{{ entity.name }} );
ARQ_REG_TYPE( ARQ::RD::Record<ARQ::RD::{{ entity.name }}> );
{% endfor %}

#pragma endregion