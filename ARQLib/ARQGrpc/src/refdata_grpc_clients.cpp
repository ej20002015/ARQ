// THIS FILE IS AUTO-GENERATED BY THE CODE-GEN SCRIPT. DO NOT EDIT.
// Contains gRPC client stub implementation for Reference Data services.

#include "refdata_grpc_clients.h"

#include <ARQUtils/error.h>
#include <ARQCore/logger.h>

#include <ARQGrpc/rd_entity_grpc_converters.h>

namespace ARQ
{
namespace Grpc
{
namespace RefData
{

/*
*********************************************
*   Implementation of RefDataReaderClient   *
*********************************************
*/

// --- Methods for Currency (CCY) ---

std::vector<RDEntities::Currency> RefDataReaderClient::getCurrencies()
{
    GetCurrenciesRequest request;
    GetCurrenciesResponse response;
    grpc::ClientContext context;

    grpc::Status status = m_stub->GetCurrencies( &context, request, &response );

    if( !status.ok() )
        throw ARQException( std::format( "Could not make getCurrencies call to RefDataReader gRPC service - response code/message: {}/{}", static_cast<uint32_t>( status.error_code() ), status.error_message() ) );
    
    const size_t numEntities = response.currencies_size();
    std::vector<RDEntities::Currency> entities;
    entities.reserve( numEntities );
    for( size_t i = 0; i < numEntities; ++i )
    {
        Currency* const entity = response.mutable_currencies( i );
        entities.push_back( fromGrpc( std::move( *entity ) ) );
    }

    return entities;
}

std::optional<RDEntities::Currency> RefDataReaderClient::getCurrency( const RDEntities::Traits<RDEntities::Currency>::KeyType& ccyID )
{
    GetCurrencyRequest request;
    request.set_ccy_id( ccyID );
    GetCurrencyResponse response;
    grpc::ClientContext context;

    grpc::Status status = m_stub->GetCurrency( &context, request, &response );
    if( !status.ok() )
        throw ARQException( std::format( "Could not make getCurrency call to RefDataReader gRPC service - response code/message: {}/{}", static_cast<uint32_t>( status.error_code() ), status.error_message() ) );
    
     if( response.found() )
        return fromGrpc( std::move( *response.mutable_currency() ) );
    else
    {
        if( response.message().size() )
            Log( Module::GRPC ).info( "getCurrency call to RefDataReader gRPC service with ccy_id [{}] found no such entity - response message: {}", ccyID, response.message() );
        return std::nullopt;
    }
}

// --- Methods for User (USER) ---

std::vector<RDEntities::User> RefDataReaderClient::getUsers()
{
    GetUsersRequest request;
    GetUsersResponse response;
    grpc::ClientContext context;

    grpc::Status status = m_stub->GetUsers( &context, request, &response );

    if( !status.ok() )
        throw ARQException( std::format( "Could not make getUsers call to RefDataReader gRPC service - response code/message: {}/{}", static_cast<uint32_t>( status.error_code() ), status.error_message() ) );
    
    const size_t numEntities = response.users_size();
    std::vector<RDEntities::User> entities;
    entities.reserve( numEntities );
    for( size_t i = 0; i < numEntities; ++i )
    {
        User* const entity = response.mutable_users( i );
        entities.push_back( fromGrpc( std::move( *entity ) ) );
    }

    return entities;
}

std::optional<RDEntities::User> RefDataReaderClient::getUser( const RDEntities::Traits<RDEntities::User>::KeyType& userID )
{
    GetUserRequest request;
    request.set_user_id( userID );
    GetUserResponse response;
    grpc::ClientContext context;

    grpc::Status status = m_stub->GetUser( &context, request, &response );
    if( !status.ok() )
        throw ARQException( std::format( "Could not make getUser call to RefDataReader gRPC service - response code/message: {}/{}", static_cast<uint32_t>( status.error_code() ), status.error_message() ) );
    
     if( response.found() )
        return fromGrpc( std::move( *response.mutable_user() ) );
    else
    {
        if( response.message().size() )
            Log( Module::GRPC ).info( "getUser call to RefDataReader gRPC service with user_id [{}] found no such entity - response message: {}", userID, response.message() );
        return std::nullopt;
    }
}


/*
*********************************************
* Implementation of RefDataGatekeeperClient *
*********************************************
*/

// --- Methods for Currency (CCY) ---

void RefDataGatekeeperClient::upsertCurrencies( const std::vector<RDEntities::Currency>& data )
{
    UpsertCurrenciesRequest request;
    for( const auto& d : data )
    {
        UpsertCurrenciesRequest::Item* const itemPtr = request.add_items();
        itemPtr->set_expected_version( d._version );
        itemPtr->set_updated_by( "ejames" ); // TODO: Change this to be the actual user
        CurrencyPayload* const payload = itemPtr->mutable_currency();
        toGrpcPayload( d, payload );
    }
    UpsertCurrenciesResponse response;
    grpc::ClientContext context;

    grpc::Status status = m_stub->UpsertCurrencies( &context, request, &response );
    if( !status.ok() )
        throw ARQException( std::format( "Could not make upsertCurrencies call to RefDataGatekeeper gRPC service - response code/message: {}/{}", static_cast<uint32_t>( status.error_code() ), status.error_message() ) );
    
    if( !response.success() ) //  TODO: Should return something
        Log( Module::GRPC ).error( "upsertCurrencies call to RefDataGatekeeper gRPC service didn't succeed in saving all items - message: {}", response.message() );
}

void RefDataGatekeeperClient::deactivateCurrencies( const std::vector<DeactivateCurrencyData>& data )
{
    DeactivateCurrenciesRequest request;
    for( const auto& [ key, version ] : data )
    {
        DeactivateCurrenciesRequest::Item* const itemPtr = request.add_items();
        itemPtr->set_ccy_id( key );
        itemPtr->set_expected_version( version );
        itemPtr->set_updated_by( "ejames" ); // TODO: Change this to be the actual user
    }
    DeactivateCurrenciesResponse response;
    grpc::ClientContext context;

    grpc::Status status = m_stub->DeactivateCurrencies( &context, request, &response );
    if( !status.ok() )
        throw ARQException( std::format( "Could not make deactivateCurrencies call to RefDataGatekeeper gRPC service - response code/message: {}/{}", static_cast<uint32_t>( status.error_code() ), status.error_message() ) );
    
    if( !response.success() ) //  TODO: Should return something
        Log( Module::GRPC ).error( "deactivateCurrencies call to RefDataGatekeeper gRPC service didn't succeed in saving all items - message: {}", response.message() );
}

// --- Methods for User (USER) ---

void RefDataGatekeeperClient::upsertUsers( const std::vector<RDEntities::User>& data )
{
    UpsertUsersRequest request;
    for( const auto& d : data )
    {
        UpsertUsersRequest::Item* const itemPtr = request.add_items();
        itemPtr->set_expected_version( d._version );
        itemPtr->set_updated_by( "ejames" ); // TODO: Change this to be the actual user
        UserPayload* const payload = itemPtr->mutable_user();
        toGrpcPayload( d, payload );
    }
    UpsertUsersResponse response;
    grpc::ClientContext context;

    grpc::Status status = m_stub->UpsertUsers( &context, request, &response );
    if( !status.ok() )
        throw ARQException( std::format( "Could not make upsertUsers call to RefDataGatekeeper gRPC service - response code/message: {}/{}", static_cast<uint32_t>( status.error_code() ), status.error_message() ) );
    
    if( !response.success() ) //  TODO: Should return something
        Log( Module::GRPC ).error( "upsertUsers call to RefDataGatekeeper gRPC service didn't succeed in saving all items - message: {}", response.message() );
}

void RefDataGatekeeperClient::deactivateUsers( const std::vector<DeactivateUserData>& data )
{
    DeactivateUsersRequest request;
    for( const auto& [ key, version ] : data )
    {
        DeactivateUsersRequest::Item* const itemPtr = request.add_items();
        itemPtr->set_user_id( key );
        itemPtr->set_expected_version( version );
        itemPtr->set_updated_by( "ejames" ); // TODO: Change this to be the actual user
    }
    DeactivateUsersResponse response;
    grpc::ClientContext context;

    grpc::Status status = m_stub->DeactivateUsers( &context, request, &response );
    if( !status.ok() )
        throw ARQException( std::format( "Could not make deactivateUsers call to RefDataGatekeeper gRPC service - response code/message: {}/{}", static_cast<uint32_t>( status.error_code() ), status.error_message() ) );
    
    if( !response.success() ) //  TODO: Should return something
        Log( Module::GRPC ).error( "deactivateUsers call to RefDataGatekeeper gRPC service didn't succeed in saving all items - message: {}", response.message() );
}


}
}
}