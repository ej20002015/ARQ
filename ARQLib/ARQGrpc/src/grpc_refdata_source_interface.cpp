// THIS FILE IS AUTO-GENERATED BY THE CODE-GEN SCRIPT. DO NOT EDIT.
// Contains the full implementation of the GrpcRefDataSource class.

#include <ARQGrpc/grpc_refdata_source_interface.h>

#include <ARQUtils/error.h>
#include <ARQUtils/instr.h>
#include <ARQCore/logger.h>

#include <proto_gen/refdata_protobuf.grpc.pb.h>

#include "channel_manager.h"
#include "refdata_grpc_clients.h"

namespace ARQ
{


// --- Implementation for Currency ---

static std::vector<RDEntities::Currency> internalFetchCurrencies( const std::string_view dsh, const std::optional<std::reference_wrapper<const RDEntities::Traits<RDEntities::Currency>::KeyType>> ccyID = std::nullopt )
{
    const bool singleFetch = ccyID.has_value();

    std::vector<RDEntities::Currency> results;

    Instr::Timer tm;

    try
    {
        std::shared_ptr<grpc::Channel> channel = ChannelManager::inst().get( dsh, "RefDataReader" );

        ARQ::Grpc::RefData::RefDataReaderClient client( channel );
        if( singleFetch )
        {
            std::optional<RDEntities::Currency> result = client.getCurrency( *ccyID );
            if( result.has_value() )
                results.push_back( std::move( *result ) );
        }
        else
            results = client.getCurrencies();
    }
    catch( const ARQException& e )
    {
        throw ARQException( std::format( "Error invoking gRPC RefDataReader::get{} function: {}", singleFetch ? "Currency" : "Currencies", e.what() ) );
    }
    catch( const std::exception& e )
    {
        throw ARQException( std::format( "Error invoking gRPC RefDataReader::get{} function: {}", singleFetch ? "Currency" : "Currencies", e.what() ) );
    }

    Log( Module::GRPC ).debug( "Completed gRPC RefDataReader::get{} function call in {}", singleFetch ? "Currency" : "Currencies", tm.duration() );

    return results;
}

std::vector<RDEntities::Currency> GrpcRefDataSource::fetchCurrencies()
{
    return internalFetchCurrencies( m_dsh );
}

std::optional<RDEntities::Currency> GrpcRefDataSource::fetchCurrency( const RDEntities::Traits<RDEntities::Currency>::KeyType& ccyID )
{
    auto result = internalFetchCurrencies( m_dsh, ccyID );
    return result.empty() ? std::nullopt : std::make_optional( std::move( result.front() ) );
}

// TODO: Need to implement fetchAsOfCurrencies in a similar manner
// TODO: Need to create some audit load capability

[[nodiscard]] std::vector<RDEntities::Currency> GrpcRefDataSource::fetchAsOfCurrencies( const Time::DateTime asof )
{
    return std::vector<RDEntities::Currency>();
}

void GrpcRefDataSource::upsertCurrencies( const std::vector<RDEntities::Currency>& data )
{
    Instr::Timer tm;

    try
    {
        std::shared_ptr<grpc::Channel> channel = ChannelManager::inst().get( m_dsh, "RefDataGatekeeper" );

        ARQ::Grpc::RefData::RefDataGatekeeperClient client( channel );
        client.upsertCurrencies( data );
    }
    catch( const ARQException& e )
    {
        throw ARQException( std::format( "Error invoking gRPC RefDataGatekeeper::upsertCurrencies function: {}", e.what() ) );
    }
    catch( const std::exception& e )
    {
        throw ARQException( std::format( "Error invoking gRPC RefDataGatekeeper::upsertCurrencies function: {}", e.what() ) );
    }

    Log( Module::GRPC ).debug( "Completed gRPC RefDataGatekeeper::upsertCurrencies function call in {}", tm.duration() );
}

// --- Implementation for User ---

static std::vector<RDEntities::User> internalFetchUsers( const std::string_view dsh, const std::optional<std::reference_wrapper<const RDEntities::Traits<RDEntities::User>::KeyType>> userID = std::nullopt )
{
    const bool singleFetch = userID.has_value();

    std::vector<RDEntities::User> results;

    Instr::Timer tm;

    try
    {
        std::shared_ptr<grpc::Channel> channel = ChannelManager::inst().get( dsh, "RefDataReader" );

        ARQ::Grpc::RefData::RefDataReaderClient client( channel );
        if( singleFetch )
        {
            std::optional<RDEntities::User> result = client.getUser( *userID );
            if( result.has_value() )
                results.push_back( std::move( *result ) );
        }
        else
            results = client.getUsers();
    }
    catch( const ARQException& e )
    {
        throw ARQException( std::format( "Error invoking gRPC RefDataReader::get{} function: {}", singleFetch ? "User" : "Users", e.what() ) );
    }
    catch( const std::exception& e )
    {
        throw ARQException( std::format( "Error invoking gRPC RefDataReader::get{} function: {}", singleFetch ? "User" : "Users", e.what() ) );
    }

    Log( Module::GRPC ).debug( "Completed gRPC RefDataReader::get{} function call in {}", singleFetch ? "User" : "Users", tm.duration() );

    return results;
}

std::vector<RDEntities::User> GrpcRefDataSource::fetchUsers()
{
    return internalFetchUsers( m_dsh );
}

std::optional<RDEntities::User> GrpcRefDataSource::fetchUser( const RDEntities::Traits<RDEntities::User>::KeyType& userID )
{
    auto result = internalFetchUsers( m_dsh, userID );
    return result.empty() ? std::nullopt : std::make_optional( std::move( result.front() ) );
}

// TODO: Need to implement fetchAsOfUsers in a similar manner
// TODO: Need to create some audit load capability

[[nodiscard]] std::vector<RDEntities::User> GrpcRefDataSource::fetchAsOfUsers( const Time::DateTime asof )
{
    return std::vector<RDEntities::User>();
}

void GrpcRefDataSource::upsertUsers( const std::vector<RDEntities::User>& data )
{
    Instr::Timer tm;

    try
    {
        std::shared_ptr<grpc::Channel> channel = ChannelManager::inst().get( m_dsh, "RefDataGatekeeper" );

        ARQ::Grpc::RefData::RefDataGatekeeperClient client( channel );
        client.upsertUsers( data );
    }
    catch( const ARQException& e )
    {
        throw ARQException( std::format( "Error invoking gRPC RefDataGatekeeper::upsertUsers function: {}", e.what() ) );
    }
    catch( const std::exception& e )
    {
        throw ARQException( std::format( "Error invoking gRPC RefDataGatekeeper::upsertUsers function: {}", e.what() ) );
    }

    Log( Module::GRPC ).debug( "Completed gRPC RefDataGatekeeper::upsertUsers function call in {}", tm.duration() );
}


}