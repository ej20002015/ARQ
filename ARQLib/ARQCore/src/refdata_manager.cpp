// THIS FILE IS AUTO-GENERATED BY THE CODE-GEN SCRIPT. DO NOT EDIT.
// Contains implementation of the RefDataManager class.

#include <ARQCore/refdata_manager.h>

namespace ARQ
{

// --- Implementation for Currency (CCY) ---

[[nodiscard]] bool RefDataManager::hasCurrencies() const
{
    std::shared_lock<std::shared_mutex> sl( m_mut );
    return m_Currencies != nullptr;
}

[[nodiscard]] std::shared_ptr<RefDataCache<RDEntities::Currency>> RefDataManager::Currencies() const
{
    if( !hasCurrencies() )
        const_cast<RefDataManager*>( this )->loadInitiallyCurrencies();

	return m_Currencies;
}

void RefDataManager::reloadCurrencies()
{
    Log( Module::REFDATA ).debug( "RefDataManager: Reloading {} data", RDEntities::Traits<RDEntities::Currency>::name() );

    std::map<RDEntities::Traits<RDEntities::Currency>::KeyType, RDEntities::Currency> newData;
    auto objs = m_rdSource->fetchLatestCurrencies();
    for( auto&& obj : std::move( objs ) )
        newData.emplace( obj.ccyID, std::move( obj ) );

    std::unique_lock<std::shared_mutex> ul( m_mut );
    m_Currencies = std::make_shared<RefDataCache<RDEntities::Currency>>( std::move( newData ) );

    Log( Module::REFDATA ).debug( "RefDataManager: Reloaded {} data, count: {}", RDEntities::Traits<RDEntities::Currency>::name(), m_Currencies->m_map.size() );
}

void RefDataManager::loadInitiallyCurrencies()
{
	std::unique_lock<std::shared_mutex> ul( m_mut );

	if( m_Currencies )
	{
		Log( Module::REFDATA ).debug( "RefDataManager: Skipping initial load - already loaded {} data, count: {}", RDEntities::Traits<RDEntities::Currency>::name(), m_Currencies->m_map.size() );
		return;
	}

	Log( Module::REFDATA ).debug( "RefDataManager: Doing initial load of {} data", RDEntities::Traits<RDEntities::Currency>::name() );

    std::map<RDEntities::Traits<RDEntities::Currency>::KeyType, RDEntities::Currency> newData;
    auto objs = m_rdSource->fetchLatestCurrencies();
    for( auto&& obj : std::move( objs ) )
        newData.emplace( obj.ccyID, std::move( obj ) );

    m_Currencies = std::make_shared<RefDataCache<RDEntities::Currency>>( std::move( newData ) );

    Log( Module::REFDATA ).debug( "RefDataManager: Completed initial load of {} data, count: {}", RDEntities::Traits<RDEntities::Currency>::name(), m_Currencies->m_map.size() );
}

void RefDataManager::insertCurrencies( const std::vector<RDEntities::Currency>& data, const StaleCheck staleCheck )
{
    Log( Module::REFDATA ).info( "RefDataManager: Inserting {} data, count: {}", RDEntities::Traits<RDEntities::Currency>::name(), data.size() );

    if( staleCheck == USING_CACHE || staleCheck == USING_DB ) // TODO: Should be checking this as part of the DB transaction
    {
		if( !hasCurrencies() )
			loadInitiallyCurrencies();
		else if( staleCheck == USING_DB )
			reloadCurrencies();

        auto rdCache = m_Currencies;

        for( const RDEntities::Currency& dataItem : data )
        {
            const auto cachedItem = rdCache->get( dataItem.ccyID );
            if( cachedItem && cachedItem->get()._lastUpdatedTs > dataItem._lastUpdatedTs )
            {
                throw ARQException( std::format( "RefDataManager: Not inserting refdata due to stale record for {}.{} - ts of record to insert is {}; ts of record in cache is {}",
                                                  RDEntities::Traits<RDEntities::Currency>::name(), dataItem.ccyID, dataItem._lastUpdatedTs, cachedItem->get()._lastUpdatedTs ) );
            }
        }
    }

    m_rdSource->insertCurrencies( data );

    Log( Module::REFDATA ).info( "RefDataManager: Inserted {} data, count: {}", RDEntities::Traits<RDEntities::Currency>::name(), data.size() );

    // Reload the cache after insertion
    reloadCurrencies();
}

void RefDataManager::insertCurrency( const RDEntities::Currency& data, const StaleCheck staleCheck )
{
    insertCurrencies( std::vector<RDEntities::Currency>{ data }, staleCheck );
}

// --- Implementation for User (USER) ---

[[nodiscard]] bool RefDataManager::hasUsers() const
{
    std::shared_lock<std::shared_mutex> sl( m_mut );
    return m_Users != nullptr;
}

[[nodiscard]] std::shared_ptr<RefDataCache<RDEntities::User>> RefDataManager::Users() const
{
    if( !hasUsers() )
        const_cast<RefDataManager*>( this )->loadInitiallyUsers();

	return m_Users;
}

void RefDataManager::reloadUsers()
{
    Log( Module::REFDATA ).debug( "RefDataManager: Reloading {} data", RDEntities::Traits<RDEntities::User>::name() );

    std::map<RDEntities::Traits<RDEntities::User>::KeyType, RDEntities::User> newData;
    auto objs = m_rdSource->fetchLatestUsers();
    for( auto&& obj : std::move( objs ) )
        newData.emplace( obj.userID, std::move( obj ) );

    std::unique_lock<std::shared_mutex> ul( m_mut );
    m_Users = std::make_shared<RefDataCache<RDEntities::User>>( std::move( newData ) );

    Log( Module::REFDATA ).debug( "RefDataManager: Reloaded {} data, count: {}", RDEntities::Traits<RDEntities::User>::name(), m_Users->m_map.size() );
}

void RefDataManager::loadInitiallyUsers()
{
	std::unique_lock<std::shared_mutex> ul( m_mut );

	if( m_Users )
	{
		Log( Module::REFDATA ).debug( "RefDataManager: Skipping initial load - already loaded {} data, count: {}", RDEntities::Traits<RDEntities::User>::name(), m_Users->m_map.size() );
		return;
	}

	Log( Module::REFDATA ).debug( "RefDataManager: Doing initial load of {} data", RDEntities::Traits<RDEntities::User>::name() );

    std::map<RDEntities::Traits<RDEntities::User>::KeyType, RDEntities::User> newData;
    auto objs = m_rdSource->fetchLatestUsers();
    for( auto&& obj : std::move( objs ) )
        newData.emplace( obj.userID, std::move( obj ) );

    m_Users = std::make_shared<RefDataCache<RDEntities::User>>( std::move( newData ) );

    Log( Module::REFDATA ).debug( "RefDataManager: Completed initial load of {} data, count: {}", RDEntities::Traits<RDEntities::User>::name(), m_Users->m_map.size() );
}

void RefDataManager::insertUsers( const std::vector<RDEntities::User>& data, const StaleCheck staleCheck )
{
    Log( Module::REFDATA ).info( "RefDataManager: Inserting {} data, count: {}", RDEntities::Traits<RDEntities::User>::name(), data.size() );

    if( staleCheck == USING_CACHE || staleCheck == USING_DB ) // TODO: Should be checking this as part of the DB transaction
    {
		if( !hasUsers() )
			loadInitiallyUsers();
		else if( staleCheck == USING_DB )
			reloadUsers();

        auto rdCache = m_Users;

        for( const RDEntities::User& dataItem : data )
        {
            const auto cachedItem = rdCache->get( dataItem.userID );
            if( cachedItem && cachedItem->get()._lastUpdatedTs > dataItem._lastUpdatedTs )
            {
                throw ARQException( std::format( "RefDataManager: Not inserting refdata due to stale record for {}.{} - ts of record to insert is {}; ts of record in cache is {}",
                                                  RDEntities::Traits<RDEntities::User>::name(), dataItem.userID, dataItem._lastUpdatedTs, cachedItem->get()._lastUpdatedTs ) );
            }
        }
    }

    m_rdSource->insertUsers( data );

    Log( Module::REFDATA ).info( "RefDataManager: Inserted {} data, count: {}", RDEntities::Traits<RDEntities::User>::name(), data.size() );

    // Reload the cache after insertion
    reloadUsers();
}

void RefDataManager::insertUser( const RDEntities::User& data, const StaleCheck staleCheck )
{
    insertUsers( std::vector<RDEntities::User>{ data }, staleCheck );
}



}