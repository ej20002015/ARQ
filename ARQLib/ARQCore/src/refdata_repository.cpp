// THIS FILE IS AUTO-GENERATED BY THE CODE-GEN SCRIPT. DO NOT EDIT.
// Contains the Repository class and its cache for Reference Data entities.

#include <ARQCore/refdata_repository.h>

namespace ARQ::RD
{

// --- Implementation for Currency (CCY) ---

[[nodiscard]] bool Repository::hasCurrencies() const
{
    std::shared_lock<std::shared_mutex> sl( m_mut );
    return m_Currencies != nullptr;
}

[[nodiscard]] std::shared_ptr<Cache<Currency>> Repository::Currencies() const
{
    if( !hasCurrencies() )
        const_cast<Repository*>( this )->loadInitiallyCurrencies();

	return m_Currencies;
}

void Repository::reloadCurrencies()
{
    Log( Module::REFDATA ).debug( "Repository: Reloading {} data", Traits<Currency>::name() );

    std::map<ID::UUID, Currency> newData;
    auto objs = m_rdSource->fetchCurrencies();
    for( auto&& obj : std::move( objs ) )
        newData.emplace( obj.uuid, std::move( obj ) );

    std::unique_lock<std::shared_mutex> ul( m_mut );
    m_Currencies = std::make_shared<Cache<Currency>>( std::move( newData ) );

    Log( Module::REFDATA ).debug( "Repository: Reloaded {} data, count: {}", Traits<Currency>::name(), m_Currencies->m_map.size() );
}

void Repository::loadInitiallyCurrencies()
{
	std::unique_lock<std::shared_mutex> ul( m_mut );

	if( m_Currencies )
	{
		Log( Module::REFDATA ).debug( "Repository: Skipping initial load - already loaded {} data, count: {}", Traits<Currency>::name(), m_Currencies->m_map.size() );
		return;
	}

	Log( Module::REFDATA ).debug( "Repository: Doing initial load of {} data", Traits<Currency>::name() );

    std::map<ID::UUID, Currency> newData;
    auto objs = m_rdSource->fetchCurrencies();
    for( auto&& obj : std::move( objs ) )
        newData.emplace( obj.uuid, std::move( obj ) );

    m_Currencies = std::make_shared<Cache<Currency>>( std::move( newData ) );

    Log( Module::REFDATA ).debug( "Repository: Completed initial load of {} data, count: {}", Traits<Currency>::name(), m_Currencies->m_map.size() );
}

// --- Implementation for User (USER) ---

[[nodiscard]] bool Repository::hasUsers() const
{
    std::shared_lock<std::shared_mutex> sl( m_mut );
    return m_Users != nullptr;
}

[[nodiscard]] std::shared_ptr<Cache<User>> Repository::Users() const
{
    if( !hasUsers() )
        const_cast<Repository*>( this )->loadInitiallyUsers();

	return m_Users;
}

void Repository::reloadUsers()
{
    Log( Module::REFDATA ).debug( "Repository: Reloading {} data", Traits<User>::name() );

    std::map<ID::UUID, User> newData;
    auto objs = m_rdSource->fetchUsers();
    for( auto&& obj : std::move( objs ) )
        newData.emplace( obj.uuid, std::move( obj ) );

    std::unique_lock<std::shared_mutex> ul( m_mut );
    m_Users = std::make_shared<Cache<User>>( std::move( newData ) );

    Log( Module::REFDATA ).debug( "Repository: Reloaded {} data, count: {}", Traits<User>::name(), m_Users->m_map.size() );
}

void Repository::loadInitiallyUsers()
{
	std::unique_lock<std::shared_mutex> ul( m_mut );

	if( m_Users )
	{
		Log( Module::REFDATA ).debug( "Repository: Skipping initial load - already loaded {} data, count: {}", Traits<User>::name(), m_Users->m_map.size() );
		return;
	}

	Log( Module::REFDATA ).debug( "Repository: Doing initial load of {} data", Traits<User>::name() );

    std::map<ID::UUID, User> newData;
    auto objs = m_rdSource->fetchUsers();
    for( auto&& obj : std::move( objs ) )
        newData.emplace( obj.uuid, std::move( obj ) );

    m_Users = std::make_shared<Cache<User>>( std::move( newData ) );

    Log( Module::REFDATA ).debug( "Repository: Completed initial load of {} data, count: {}", Traits<User>::name(), m_Users->m_map.size() );
}

}