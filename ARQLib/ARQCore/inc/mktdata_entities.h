// THIS FILE IS AUTO-GENERATED BY THE CODE-GEN SCRIPT. DO NOT EDIT.
// Contains C++ definitions for Market Data entities.

#pragma once

#include <ARQUtils/core.h>
#include <ARQUtils/time.h>

#include <string>
#include <cstdint>
#include <concepts>
#include <string_view>
#include <array>
#include <utility>
#include <optional>

namespace ARQ
{
namespace MDEntities
{

/*
*************************************************
* Common functionality for Market Data Entities *
*************************************************
*/

// Base struct for all market data entities
struct MDEntity
{
    bool _isActive = true;
    Time::DateTime _lastUpdatedTs;
    std::string _lastUpdatedBy;

    /// The unique identifier for the market data entity.
	std::string ID;
    /// The source of the market data.
	std::string source;
    /// The point-in-time when the market data was effective.
	Time::DateTime asofTs;
};

template<typename T>
concept c_MDEntity = std::is_base_of_v<MDEntity, T>;

enum class Type
{
    _NOTSET_ = -1,
    FXR,
    EQP,
};

inline std::string_view typeToStr( const Type type )
{
    switch( type )
    {
        case Type::FXR: return "FXR";
        case Type::EQP: return "EQP";
        default:
            ARQ_ASSERT( false ); return "Unknown";
    }
}

// Traits class to get compile-time metadata about an entity
template<c_MDEntity T>
class Traits
{
public:
    static consteval std::string_view const name()      { static_assert( false, "Missing MDEntities::Traits specialization for this type" ); return ""; }
    static consteval std::string_view const type()      { static_assert( false, "Missing MDEntities::Traits specialization for this type" ); return ""; }
    static consteval Type             const typeEnum()  { static_assert( false, "Missing MDEntities::Traits specialization for this type" ); return Type::FXR; }
    static consteval std::string_view const tableName() { static_assert( false, "Missing MDEntities::Traits specialization for this type" ); return ""; }
};

struct MemberInfo
{
    /// Name of the C++ member variable
    const std::string_view name;
    /// Documentation string
    const std::string_view comment;
    /// The language agnostic type as a string
    const std::string_view type;
    /// The C++ type as a string
    const std::string_view cppType;
    /// The ClickHouse type as a string
    const std::string_view clickhouseType;
    /// The FlatBuffers type as a string
    const std::string_view flatbufferType;
};

/*
********************************************
*            Entity Definitions            *
********************************************
*/


/// Represents a foreign exchange spot rate.
struct FXRate : public MDEntity
{
    /// The mid-market rate.
    double mid;
    /// The price at which a market maker is willing to buy.
    double bid;
    /// The price at which a market maker is willing to sell.
    double ask;
};

// Traits specialization for FXRate
template<>
class Traits<FXRate>
{
public:
    static consteval std::string_view const name()      { return "FXRate"; }
    static consteval std::string_view const type()      { return "FXR"; }
    static consteval Type             const typeEnum()  { return Type::FXR; }
    static consteval std::string_view const tableName() { return "FXRates"; }

    // A compile-time array holding metadata for all members.
    static constexpr std::array<MemberInfo, 3> membersInfo =
    {
        MemberInfo {
            /*name            = */ "mid",
            /*comment         = */ "The mid-market rate.",
            /*type            = */ "double",
            /*cpp_type        = */ "double",
            /*clickhouse_type = */ "Float64",
            /*flatbuffer_type = */ "double"
        },
        MemberInfo {
            /*name            = */ "bid",
            /*comment         = */ "The price at which a market maker is willing to buy.",
            /*type            = */ "double",
            /*cpp_type        = */ "double",
            /*clickhouse_type = */ "Float64",
            /*flatbuffer_type = */ "double"
        },
        MemberInfo {
            /*name            = */ "ask",
            /*comment         = */ "The price at which a market maker is willing to sell.",
            /*type            = */ "double",
            /*cpp_type        = */ "double",
            /*clickhouse_type = */ "Float64",
            /*flatbuffer_type = */ "double"
        }    
    };

    // A compile-time helper function to look up info for a specific member.
    static consteval std::optional<MemberInfo> getMemberInfo( const std::string_view memberName )
    {
        for( const auto& info : membersInfo )
        {
            if( info.name == memberName )
                return info;
        }
        return std::nullopt;
    }
};


/// Represents pricing information for an equity.
struct EQPrice : public MDEntity
{
    /// The price of the last executed trade.
    double last;
    /// The highest price a buyer is willing to pay.
    double bid;
    /// The lowest price a seller is willing to accept.
    double ask;
    /// The opening price for the current trading session.
    double open;
    /// The closing price from the previous trading session.
    double close;
    /// The cumulative volume for the current trading session.
    std::int64_t volume;
};

// Traits specialization for EQPrice
template<>
class Traits<EQPrice>
{
public:
    static consteval std::string_view const name()      { return "EQPrice"; }
    static consteval std::string_view const type()      { return "EQP"; }
    static consteval Type             const typeEnum()  { return Type::EQP; }
    static consteval std::string_view const tableName() { return "EQPrices"; }

    // A compile-time array holding metadata for all members.
    static constexpr std::array<MemberInfo, 6> membersInfo =
    {
        MemberInfo {
            /*name            = */ "last",
            /*comment         = */ "The price of the last executed trade.",
            /*type            = */ "double",
            /*cpp_type        = */ "double",
            /*clickhouse_type = */ "Float64",
            /*flatbuffer_type = */ "double"
        },
        MemberInfo {
            /*name            = */ "bid",
            /*comment         = */ "The highest price a buyer is willing to pay.",
            /*type            = */ "double",
            /*cpp_type        = */ "double",
            /*clickhouse_type = */ "Float64",
            /*flatbuffer_type = */ "double"
        },
        MemberInfo {
            /*name            = */ "ask",
            /*comment         = */ "The lowest price a seller is willing to accept.",
            /*type            = */ "double",
            /*cpp_type        = */ "double",
            /*clickhouse_type = */ "Float64",
            /*flatbuffer_type = */ "double"
        },
        MemberInfo {
            /*name            = */ "open",
            /*comment         = */ "The opening price for the current trading session.",
            /*type            = */ "double",
            /*cpp_type        = */ "double",
            /*clickhouse_type = */ "Float64",
            /*flatbuffer_type = */ "double"
        },
        MemberInfo {
            /*name            = */ "close",
            /*comment         = */ "The closing price from the previous trading session.",
            /*type            = */ "double",
            /*cpp_type        = */ "double",
            /*clickhouse_type = */ "Float64",
            /*flatbuffer_type = */ "double"
        },
        MemberInfo {
            /*name            = */ "volume",
            /*comment         = */ "The cumulative volume for the current trading session.",
            /*type            = */ "int64",
            /*cpp_type        = */ "std::int64_t",
            /*clickhouse_type = */ "Int64",
            /*flatbuffer_type = */ "long"
        }    
    };

    // A compile-time helper function to look up info for a specific member.
    static consteval std::optional<MemberInfo> getMemberInfo( const std::string_view memberName )
    {
        for( const auto& info : membersInfo )
        {
            if( info.name == memberName )
                return info;
        }
        return std::nullopt;
    }
};

}
}