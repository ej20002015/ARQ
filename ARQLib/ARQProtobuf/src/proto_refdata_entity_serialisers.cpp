// THIS FILE IS AUTO-GENERATED BY THE CODE-GEN SCRIPT. DO NOT EDIT.
// Contains (de)serialisation code for refdata entities

#include "proto_refdata_entity_serialisers.h"

#include <ARQUtils/id.h>
#include <ARQProtobuf/rd_entity_proto_converters.h>
#include "helpers.h"

#include <proto_gen/refdata_entities.pb.h>

namespace ARQ::Proto::RD
{

void registerRefDataEntitySerialisers( Serialiser& serialiser )
{
    serialiser.registerHandler<ARQ::RD::Record<ARQ::RD::Currency>>( std::make_unique<ProtobufTypeSerialiser_RDRecord<ARQ::RD::Currency>>() );
    serialiser.registerHandler<ARQ::RD::Record<ARQ::RD::User>>( std::make_unique<ProtobufTypeSerialiser_RDRecord<ARQ::RD::User>>() );
}

/*
**************************************************
* Helpers for RefData entity proto serialisation *
**************************************************
*/

template<typename ProtoType>
void setRecordHeaderFields( ProtoType& protoObj, const ARQ::RD::RecordHeader& arqRecordHeader )
{
	ARQ::Proto::RD::RecordHeader* const recordHeaderPtr = protoObj.mutable_header();

    ARQ::Proto::ID::UUID* uuidPtr = recordHeaderPtr->mutable_uuid();
    std::string* uuidBufPtr = uuidPtr->mutable_id();
    *uuidBufPtr = arqRecordHeader.uuid.toString();

	recordHeaderPtr->set_is_active( arqRecordHeader.isActive );
	recordHeaderPtr->set_last_updated_ts( arqRecordHeader.lastUpdatedTs.microsecondsSinceEpoch() );
	recordHeaderPtr->set_last_updated_by( arqRecordHeader.lastUpdatedBy );
	recordHeaderPtr->set_version( arqRecordHeader.version );
}

template<typename ProtoType>
ARQ::RD::RecordHeader getRecordHeaderFromProto( ProtoType& protoObj )
{
	ARQ::Proto::RD::RecordHeader* const protoHeaderPtr = protoObj.mutable_header();

	return {
		.uuid          = ARQ::ID::UUID::fromString( protoHeaderPtr->uuid().id() ),
		.isActive      = protoHeaderPtr->is_active(),
		.lastUpdatedTs = Time::DateTime( Time::Microseconds( protoHeaderPtr->last_updated_ts() ) ),
		.lastUpdatedBy = std::move( *protoHeaderPtr->mutable_last_updated_by() ),
		.version       = protoHeaderPtr->version()
	};
}

/*
************************************************************
* Protobuf TypeSerialiser definitions for refdata entities *
************************************************************
*/

// -------------------- Currency RefData Entity --------------------

template<>
Buffer ProtobufTypeSerialiser_RDRecord<ARQ::RD::Currency>::serialise( const ARQ::RD::Record<ARQ::RD::Currency>& obj ) const
{
	CurrencyRecord protoObj;
	setRecordHeaderFields( protoObj, obj.header );

	Currency* dataPtr = protoObj.mutable_data();
	toProto( obj.data, dataPtr );

	return serialiseToBuffer( protoObj );
}

template<>
void ProtobufTypeSerialiser_RDRecord<ARQ::RD::Currency>::deserialise( const BufferView buf, ARQ::RD::Record<ARQ::RD::Currency>& objOut ) const
{
	CurrencyRecord protoObj;
	if( !protoObj.ParseFromArray( buf.data, buf.size ) )
		throw ARQException( "Cannot deserialise buffer into RefData Currency Record" );

	objOut.header = getRecordHeaderFromProto( protoObj );
	objOut.data = fromProto( std::move( *protoObj.mutable_data() ) );
}

// -------------------- User RefData Entity --------------------

template<>
Buffer ProtobufTypeSerialiser_RDRecord<ARQ::RD::User>::serialise( const ARQ::RD::Record<ARQ::RD::User>& obj ) const
{
	UserRecord protoObj;
	setRecordHeaderFields( protoObj, obj.header );

	User* dataPtr = protoObj.mutable_data();
	toProto( obj.data, dataPtr );

	return serialiseToBuffer( protoObj );
}

template<>
void ProtobufTypeSerialiser_RDRecord<ARQ::RD::User>::deserialise( const BufferView buf, ARQ::RD::Record<ARQ::RD::User>& objOut ) const
{
	UserRecord protoObj;
	if( !protoObj.ParseFromArray( buf.data, buf.size ) )
		throw ARQException( "Cannot deserialise buffer into RefData User Record" );

	objOut.header = getRecordHeaderFromProto( protoObj );
	objOut.data = fromProto( std::move( *protoObj.mutable_data() ) );
}

}