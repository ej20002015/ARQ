// THIS FILE IS AUTO-GENERATED BY THE CODE-GEN SCRIPT. DO NOT EDIT.
// Contains (de)serialisation code for refdata entities and commands

#include "proto_refdata_type_serialisers.h"

#include "proto_gen/refdata.pb.h"

namespace ARQ
{

void registerRefDataSerialisers( Serialiser& serialiser )
{
    serialiser.registerHandler<UpsertCurrencies>( std::make_unique<ProtobufTypeSerialiser_UpsertCurrencies>() );
    serialiser.registerHandler<DeactivateCurrencies>( std::make_unique<ProtobufTypeSerialiser_DeactivateCurrencies>() );
    serialiser.registerHandler<UpsertUsers>( std::make_unique<ProtobufTypeSerialiser_UpsertUsers>() );
    serialiser.registerHandler<DeactivateUsers>( std::make_unique<ProtobufTypeSerialiser_DeactivateUsers>() );
}

/*
================== Helpers ==================
*/

void toProto( const RDEntities::Currency arqEntity, ARQ::Proto::RefData::Currency* protoEntity )
{
    protoEntity->set__is_active( arqEntity._isActive );
    protoEntity->set__last_updated_ts( arqEntity._lastUpdatedTs.microsecondsSinceEpoch() );
    protoEntity->set__last_updated_by( std::move( arqEntity._lastUpdatedBy ) );
    protoEntity->set__version( arqEntity._version );

    CurrencyPayload* const payload = grpcEntity->mutable_payload();
    payload->set_ccy_id( arqEntity.ccyID );
    payload->set_name( arqEntity.name );
    payload->set_decimal_places( arqEntity.decimalPlaces );
    payload->set_settlement_days( arqEntity.settlementDays );
}

void toProto( const RDEntities::User arqEntity, ARQ::Proto::RefData::User* protoEntity )
{
    protoEntity->set__is_active( arqEntity._isActive );
    protoEntity->set__last_updated_ts( arqEntity._lastUpdatedTs.microsecondsSinceEpoch() );
    protoEntity->set__last_updated_by( std::move( arqEntity._lastUpdatedBy ) );
    protoEntity->set__version( arqEntity._version );

    UserPayload* const payload = grpcEntity->mutable_payload();
    payload->set_user_id( arqEntity.userID );
    payload->set_full_name( arqEntity.fullName );
    payload->set_email( arqEntity.email );
    payload->set_trading_desk( arqEntity.tradingDesk );
}


/*
================== Type Serialisers ==================
*/

// --- Commands for Currency (CCY) ---

Buffer ProtobufTypeSerialiser_UpsertCurrencies::serialise( const UpsertCurrencies& obj ) const
{
    ARQ::Proto::RefData::UpsertCurrenciesCommand protoObj;

    for( const auto& item : obj.items )
    {
        ARQ::Proto::RefData::UpsertCurrenciesCommand::Item* const protoItemPtr = request.add_items();
        protoItemPtr->set_expected_version( item.expectedVersion );
        protoItemPtr->set_updated_by( item.updatedBy );
        ARQ::Proto::RefData::Currency* const protoEntity = protoItemPtr->mutable_currency();
        toProto( item.currency, protoEntity );
    }

    Buffer protoBuf( protoObj.ByteSizeLong() );
	protoObj.SerializeToArray( protoBuf.data.get(), protoBuf.size );
	return protoBuf;
}

Buffer ProtobufTypeSerialiser_RefDataCommandResponse::serialise( const RefDataCommandResponse& obj ) const
{
	ARQ::Proto::RefDataCommandResponse resp;

	ARQ::Proto::ID::UUID* uuidPtr = resp.mutable_corr_id();
	std::string* uuidBufPtr = uuidPtr->mutable_id();
	*uuidBufPtr = obj.corrID.toString();

	resp.set_status( Enum::enum_integer( obj.status ) );
	if( obj.message )
		resp.set_message( *obj.message );

	Buffer respBuf( resp.ByteSizeLong() );
	resp.SerializeToArray( respBuf.data.get(), respBuf.size );
	return respBuf;
}

void ProtobufTypeSerialiser_RefDataCommandResponse::deserialise( const BufferView buf, RefDataCommandResponse& objOut ) const
{
	ARQ::Proto::RefDataCommandResponse resp;
	resp.ParseFromArray( buf.data, buf.size );

	objOut.corrID = ID::UUID::fromString( resp.corr_id().id() );
	const auto statusOpt = Enum::enum_cast<RefDataCommandResponse::Status>( resp.status() );
	if( statusOpt )
		objOut.status = statusOpt.value();
	else
		throw ARQException( std::format( "Cannot deserialise buffer into RefDataCommandResponse - status integer [{}] not a value in RefDataCommandResponse::Status enum", resp.status() ) );
	if( resp.has_message() )
		objOut.message = resp.message();
}

// --- Commands for User (USER) ---

Buffer ProtobufTypeSerialiser_UpsertUsers::serialise( const UpsertUsers& obj ) const
{
    ARQ::Proto::RefData::UpsertUsersCommand protoObj;

    for( const auto& item : obj.items )
    {
        ARQ::Proto::RefData::UpsertUsersCommand::Item* const protoItemPtr = request.add_items();
        protoItemPtr->set_expected_version( item.expectedVersion );
        protoItemPtr->set_updated_by( item.updatedBy );
        ARQ::Proto::RefData::User* const protoEntity = protoItemPtr->mutable_user();
        toProto( item.user, protoEntity );
    }

    Buffer protoBuf( protoObj.ByteSizeLong() );
	protoObj.SerializeToArray( protoBuf.data.get(), protoBuf.size );
	return protoBuf;
}

Buffer ProtobufTypeSerialiser_RefDataCommandResponse::serialise( const RefDataCommandResponse& obj ) const
{
	ARQ::Proto::RefDataCommandResponse resp;

	ARQ::Proto::ID::UUID* uuidPtr = resp.mutable_corr_id();
	std::string* uuidBufPtr = uuidPtr->mutable_id();
	*uuidBufPtr = obj.corrID.toString();

	resp.set_status( Enum::enum_integer( obj.status ) );
	if( obj.message )
		resp.set_message( *obj.message );

	Buffer respBuf( resp.ByteSizeLong() );
	resp.SerializeToArray( respBuf.data.get(), respBuf.size );
	return respBuf;
}

void ProtobufTypeSerialiser_RefDataCommandResponse::deserialise( const BufferView buf, RefDataCommandResponse& objOut ) const
{
	ARQ::Proto::RefDataCommandResponse resp;
	resp.ParseFromArray( buf.data, buf.size );

	objOut.corrID = ID::UUID::fromString( resp.corr_id().id() );
	const auto statusOpt = Enum::enum_cast<RefDataCommandResponse::Status>( resp.status() );
	if( statusOpt )
		objOut.status = statusOpt.value();
	else
		throw ARQException( std::format( "Cannot deserialise buffer into RefDataCommandResponse - status integer [{}] not a value in RefDataCommandResponse::Status enum", resp.status() ) );
	if( resp.has_message() )
		objOut.message = resp.message();
}


}