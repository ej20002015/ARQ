// THIS FILE IS AUTO-GENERATED BY THE CODE-GEN SCRIPT. DO NOT EDIT.
// Implements the ManagedMarket class, which manages subscriptions to market data updates.

#include <ARQMarket/managed_market.h>

#include <ARQUtils/core.h>
#include <ARQCore/logger.h>
#include <ARQCore/mktdata_source.h>

namespace ARQ
{
namespace Mkt
{

// -------------- Subscriber implementation --------------

void Subscriber::setOnMktObjUpdateFunc( OnMktObjUpdateFunc&& onMktObjUpdateFunc )
{
    std::unique_lock<std::shared_mutex> ul( m_mut );
    m_onMktObjUpdateFunc = std::move( onMktObjUpdateFunc );
}

void Subscriber::setOnFXRateUpdateFunc( OnFXRateUpdateFunc&& onFXRateUpdateFunc )
{
    std::unique_lock<std::shared_mutex> ul( m_mut );
    m_onFXRateUpdateFunc = std::move( onFXRateUpdateFunc );
}

void Subscriber::setOnEQPriceUpdateFunc( OnEQPriceUpdateFunc&& onEQPriceUpdateFunc )
{
    std::unique_lock<std::shared_mutex> ul( m_mut );
    m_onEQPriceUpdateFunc = std::move( onEQPriceUpdateFunc );
}

// -------------- ManagedMarket implementation --------------

static bool isMktObjXNewerThanY( const MDEntities::MDEntity& x, const MDEntities::MDEntity& y )
{
	return x.asofTs > y.asofTs || ( x.asofTs == y.asofTs && x._lastUpdatedTs > y._lastUpdatedTs );
}

static std::string getSubscriberName( const std::weak_ptr<Subscriber> subscriber )
{
	if( auto subSharedPtr = subscriber.lock() )
		return subSharedPtr->description().data();
	else
		return "?nullptr?";
}

void ManagedMarket::subscribe( const std::weak_ptr<Subscriber> subscriber, const ConsolidatingTIDSet& subList )
{
	std::unique_lock<std::shared_mutex> ul( m_subMut );
	m_subscriptions[subscriber].append( subList );
}

void ManagedMarket::subscribeAndLoad( const std::weak_ptr<Subscriber> subscriber, const ConsolidatingTIDSet& subList )
{
	{
		std::unique_lock<std::shared_mutex> ul( m_subMut );
		m_subscriptions[subscriber].append( subList );
	}

	load( subList );
}

void ManagedMarket::unsubscribe( const std::weak_ptr<Subscriber> subscriber, const std::optional<std::reference_wrapper<ConsolidatingTIDSet>>& subList )
{
	std::unique_lock<std::shared_mutex> ul( m_subMut );

	const auto it = m_subscriptions.find( subscriber );
	if( it == m_subscriptions.end() )
	{
		Log( Module::MKT ).warn( "ManagedMarket [{}, {}]: attempting to unsubscribe subscriber [{}] that isn't registered with the managed market", m_mktName.str(), m_dsh, getSubscriberName( subscriber ) );
		return;
	}

	if( subList.has_value() )
		it->second.remove( *subList );
	else
		m_subscriptions.erase( it );
}

bool ManagedMarket::isSubscriber( const std::weak_ptr<Subscriber> subscriber ) const
{
	std::shared_lock<std::shared_mutex> sl( m_subMut );
	return m_subscriptions.find( subscriber ) != m_subscriptions.end();
}

void ManagedMarket::load( const ConsolidatingTIDSet& toLoad )
{
	const auto mktSrc = MktDataSourceFactory::create( m_dsh );

	for( const ConsolidatingTIDSet::Item item : toLoad.getAll() )
	{
		switch( item.type )
		{
			case MDEntities::Type::FXR:
			{
				std::vector<MDEntities::FXRate> loadedObjs;
				if( !item.id.has_value() )
					loadedObjs = mktSrc->fetchFXRates( m_mktName.str() );
				else
				{
					std::optional<MDEntities::FXRate> obj = mktSrc->fetchFXRate( m_mktName.str(), *item.id );
					if( obj.has_value() )
						loadedObjs.emplace_back( std::move( *obj ) );
				}

				for( MDEntities::FXRate& loadedObj : loadedObjs )
				{
					// Use atomic check-then-set with proper locking
					auto lock = m_mkt.acquireWriteLock( { MDEntities::Type::FXR } );
					
					std::optional<MDEntities::FXRate> objInMkt = m_mkt.getFXRateUnsafe( loadedObj.ID );
					const bool insertIntoMkt = !objInMkt.has_value() || isMktObjXNewerThanY( loadedObj, *objInMkt );
					if( insertIntoMkt )
						m_mkt.setFXRateUnsafe( std::move( loadedObj ) );
				}

                break;
			}
			case MDEntities::Type::EQP:
			{
				std::vector<MDEntities::EQPrice> loadedObjs;
				if( !item.id.has_value() )
					loadedObjs = mktSrc->fetchEQPrices( m_mktName.str() );
				else
				{
					std::optional<MDEntities::EQPrice> obj = mktSrc->fetchEQPrice( m_mktName.str(), *item.id );
					if( obj.has_value() )
						loadedObjs.emplace_back( std::move( *obj ) );
				}

				for( MDEntities::EQPrice& loadedObj : loadedObjs )
				{
					// Use atomic check-then-set with proper locking
					auto lock = m_mkt.acquireWriteLock( { MDEntities::Type::EQP } );
					
					std::optional<MDEntities::EQPrice> objInMkt = m_mkt.getEQPriceUnsafe( loadedObj.ID );
					const bool insertIntoMkt = !objInMkt.has_value() || isMktObjXNewerThanY( loadedObj, *objInMkt );
					if( insertIntoMkt )
						m_mkt.setEQPriceUnsafe( std::move( loadedObj ) );
				}

                break;
			}
            default:
                ARQ_ASSERT( false );
		}
	}
}

template<MDEntities::c_MDEntity T>
void ManagedMarket::sendMktUpdateToSubscribers( const T& updatedObj )
{
	std::shared_lock<std::shared_mutex> sl( m_subMut );

	// Any subscribers that no longer exist should be removed
	std::vector<std::weak_ptr<Subscriber>> subsToRemove;

	for( const auto& [subscriber, interestedIn] : m_subscriptions )
	{
		if( interestedIn.contains( { MDEntities::Traits<T>::typeEnum(), updatedObj.ID } ) )
		{
			if( auto subSharedPtr = subscriber.lock() )
			{
                std::shared_lock<std::shared_mutex> subLock( subSharedPtr->m_mut );

				if( subSharedPtr->m_onMktObjUpdateFunc )
					subSharedPtr->m_onMktObjUpdateFunc( MDEntities::Traits<T>::typeEnum(), updatedObj.ID );

                if constexpr( std::is_same_v<T, MDEntities::FXRate> )
				{
					if( subSharedPtr->m_onFXRateUpdateFunc )
						subSharedPtr->m_onFXRateUpdateFunc( updatedObj );
				}
                if constexpr( std::is_same_v<T, MDEntities::EQPrice> )
				{
					if( subSharedPtr->m_onEQPriceUpdateFunc )
						subSharedPtr->m_onEQPriceUpdateFunc( updatedObj );
				}
			}
			else
				subsToRemove.push_back( subscriber );
		}
	}

	for( const auto subToRemove : subsToRemove )
		m_subscriptions.erase( subToRemove );
}

void ManagedMarket::onFXRateUpdate( const MDEntities::FXRate& updatedObj )
{
	{
		// Use atomic check-then-set with proper locking
		auto lock = m_mkt.acquireWriteLock( { MDEntities::Type::FXR } );
		
		std::optional<MDEntities::FXRate> objInMkt = m_mkt.getFXRateUnsafe( updatedObj.ID );
		const bool insertIntoMkt = !objInMkt.has_value() || isMktObjXNewerThanY( updatedObj, *objInMkt );

		if( !insertIntoMkt )
		{
			Log( Module::MKT ).error( "ManagedMarket [{}, {}]: Updated [FXR#{}] with asof {} is older than that already stored in the mkt which has asof {}", m_mktName.str(), m_dsh, updatedObj.ID, updatedObj.asofTs.fmtISO8601(), objInMkt->_lastUpdatedTs.fmtISO8601() );
			return;
		}

		m_mkt.setFXRateUnsafe( updatedObj );
	}
	
	sendMktUpdateToSubscribers<MDEntities::FXRate>( updatedObj );
}

void ManagedMarket::onEQPriceUpdate( const MDEntities::EQPrice& updatedObj )
{
	{
		// Use atomic check-then-set with proper locking
		auto lock = m_mkt.acquireWriteLock( { MDEntities::Type::EQP } );
		
		std::optional<MDEntities::EQPrice> objInMkt = m_mkt.getEQPriceUnsafe( updatedObj.ID );
		const bool insertIntoMkt = !objInMkt.has_value() || isMktObjXNewerThanY( updatedObj, *objInMkt );

		if( !insertIntoMkt )
		{
			Log( Module::MKT ).error( "ManagedMarket [{}, {}]: Updated [EQP#{}] with asof {} is older than that already stored in the mkt which has asof {}", m_mktName.str(), m_dsh, updatedObj.ID, updatedObj.asofTs.fmtISO8601(), objInMkt->_lastUpdatedTs.fmtISO8601() );
			return;
		}

		m_mkt.setEQPriceUnsafe( updatedObj );
	}
	
	sendMktUpdateToSubscribers<MDEntities::EQPrice>( updatedObj );
}

}
}