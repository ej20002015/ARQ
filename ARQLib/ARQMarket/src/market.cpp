// THIS FILE IS AUTO-GENERATED BY THE CODE-GEN SCRIPT. DO NOT EDIT.
// Implements the Market and MarketSnapshot classes, which hold market data entities.

#include <ARQMarket/market.h>

#include <algorithm>

namespace ARQ
{
namespace Mkt
{

// -------------- MktName implementation --------------

const Name Name::LIVE = { "LIVE", Time::Date() };

std::string Name::str() const
{
    return tag + ( date.isSet() ? std::format( "|{:%Y%m%d}", date ) : "" );
}

// -------------- Market implementation --------------

Market::Market( const MarketSnapshot& mktSnapshot )
{
    setAllFXRates( mktSnapshot.m_FXRates );
    setAllEQPrices( mktSnapshot.m_EQPrices );
}

MarketSnapshot Market::snap() const
{
    // Acquire ALL mutexes at once to ensure atomic snapshot
    std::shared_lock<std::shared_mutex> sl1( m_FXRatesMut );
    std::shared_lock<std::shared_mutex> sl2( m_EQPricesMut );

    MarketSnapshot snapshot;

    snapshot.m_FXRates = m_FXRates;
    snapshot.m_EQPrices = m_EQPrices;

    return snapshot;
}

std::shared_mutex& Market::getMutexForEntity(MDEntities::Type entityType) const
{
    switch( entityType )
    {
        case MDEntities::Type::FXR:
            return m_FXRatesMut;
        case MDEntities::Type::EQP:
            return m_EQPricesMut;
        default:
            ARQ_ASSERT( false );
            return m_FXRatesMut; // Fallback to avoid compiler warning
    }
}

// -------------- MarketReadLock implementation --------------

MarketReadLock::MarketReadLock( const Market& market )
    : MarketReadLock( market, std::vector<MDEntities::Type>{
          MDEntities::Type::FXR,
          MDEntities::Type::EQP
       })
{
}

MarketReadLock::MarketReadLock( const Market& market, const std::vector<MDEntities::Type>& entityTypes )
{
    // Sort entity types to ensure consistent lock ordering and prevent deadlocks
    std::vector<MDEntities::Type> sortedTypes = entityTypes;
    std::sort( sortedTypes.begin(), sortedTypes.end() );
    sortedTypes.erase( std::unique( sortedTypes.begin(), sortedTypes.end()), sortedTypes.end() );
    
    m_locks.reserve( sortedTypes.size() );
    // Acquire locks
    for( MDEntities::Type entityType : sortedTypes )
        m_locks.emplace_back( market.getMutexForEntity( entityType ) );
}

// -------------- MarketWriteLock implementation --------------

MarketWriteLock::MarketWriteLock( const Market& market )
    : MarketWriteLock( market, std::vector<MDEntities::Type>{
          MDEntities::Type::FXR,
          MDEntities::Type::EQP
      } )
{
}

MarketWriteLock::MarketWriteLock( const Market& market, const std::vector<MDEntities::Type>& entityTypes )
{
    // Sort entity types to ensure consistent lock ordering and prevent deadlocks
    std::vector<MDEntities::Type> sortedTypes = entityTypes;
    std::sort( sortedTypes.begin(), sortedTypes.end() );
    sortedTypes.erase( std::unique( sortedTypes.begin(), sortedTypes.end()), sortedTypes.end());

    m_locks.reserve( sortedTypes.size() );
    // Acquire locks
    for( MDEntities::Type entityType : sortedTypes )
        m_locks.emplace_back( market.getMutexForEntity( entityType ) );
}

// -------------- ConsolidatingTIDSet implementation --------------

const ConsolidatingTIDSet ConsolidatingTIDSet::ALL_TYPES = {
    { MDEntities::Type::FXR },
    { MDEntities::Type::EQP },
};

ConsolidatingTIDSet::ConsolidatingTIDSet( const std::initializer_list<Item> items )
{
    for( const Item& item : items )
        add( item );
}

bool ConsolidatingTIDSet::Item::isMatch( const ConsolidatingTIDSet::Item& other ) const
{
    if( type != other.type )
        return false;
        
    // If this item has no ID (type-level), it covers any item of the same type
    if( !id.has_value() )
        return true;
        
    // If the other item has no ID (type-level query), this specific item doesn't cover it
    if( !other.id.has_value() )
        return false;
        
    // Both have IDs, check for exact match
    return id.value() == other.id.value();
}

void ConsolidatingTIDSet::add( const Item& item )
{
    if( !item.id.has_value() )
    {
        m_list.erase( std::remove_if( m_list.begin(), m_list.end(), [&item] ( const Item& i ) { return i.type == item.type; } ), m_list.end() );
        m_list.push_back( item );
    }
    else
    {
        if( std::find( m_list.begin(), m_list.end(), item ) == m_list.end() )
            m_list.push_back( item );
    }
}

void ConsolidatingTIDSet::del( const Item& item )
{
    if( !item.id.has_value() )
        m_list.erase( std::remove_if( m_list.begin(), m_list.end(), [&item] ( const Item& i ) { return i.type == item.type; } ), m_list.end() );
    else
    {
        const auto it = std::find( m_list.begin(), m_list.end(), item );
        if( it != m_list.end() )
            m_list.erase( it );
    }
}

void ConsolidatingTIDSet::append( const ConsolidatingTIDSet& otherList )
{
    for( const Item& item : otherList.getAll() )
        add( item );
}

void ConsolidatingTIDSet::remove( const ConsolidatingTIDSet& otherList )
{
    for( const Item& item : otherList.getAll() )
        del( item );
}

bool ConsolidatingTIDSet::contains( const Item& item ) const
{
    for( const Item& listItem : m_list )
    {
        if( listItem.isMatch( item ) )
            return true;
    }

    return false;
}

}
}